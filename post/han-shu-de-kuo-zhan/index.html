<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    函数的扩展 | 正义大厅
</title>
<link rel="shortcut icon" href="https://greyseid.github.io//favicon.ico?v=1618930416730">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://greyseid.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://greyseid.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


        
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://greyseid.github.io/">
                <img class="avatar" src="https://greyseid.github.io//images/avatar.png?v=1618930416730" alt="">
            </a>
            <div class="site-title">
                <h1>
                    正义大厅
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            函数的扩展
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-11-19</time>
                            
                                <a href="https://greyseid.github.io/tag/AjqKAL42P/" class="post-tag i-tag
                            i-tag-other_4">
                            #前端
                        </a>
                                
                                <a href="https://greyseid.github.io/tag/uzhtOJ9qh/" class="post-tag i-tag
                            i-tag-info">
                            #ES6
                        </a>
                                
                        </div>
                        
                            <div class="post-feature-image" style="background-image: url('https://greyseid.github.io//post-images/han-shu-de-kuo-zhan.jpg')"></div>
                            
                                <div class="post-content">
                                    <p><ul class="markdownIt-TOC">
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">函数参数的默认值</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>
<li><a href="#%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E9%BB%98%E8%AE%A4%E5%80%BC%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8">与解构赋值默认值结合使用</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE">参数默认值的位置</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84length%E5%B1%9E%E6%80%A7">函数的length属性</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#rest%E5%8F%82%E6%95%B0">rest参数</a></li>
<li><a href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">严格模式</a></li>
<li><a href="#name%E5%B1%9E%E6%80%A7">name属性</a></li>
<li><a href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">箭头函数</a>
<ul>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
<li><a href="#%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88">不适用场合</a></li>
<li><a href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">嵌套的箭头函数</a></li>
</ul>
</li>
<li><a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96">尾调用优化</a>
<ul>
<li><a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96-2">尾调用优化</a></li>
<li><a href="#%E5%B0%BE%E9%80%92%E5%BD%92">尾递归</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%B9%E5%86%99">递归函数的改写</a></li>
<li><a href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-2">严格模式</a></li>
<li><a href="#%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0">尾递归优化的实现</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%B0%BE%E9%80%97%E5%8F%B7">函数参数的尾逗号</a></li>
<li><a href="#functionprototypetostring">Function.prototype.toString()</a></li>
<li><a href="#catch%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E7%9C%81%E7%95%A5">catch命令的参数省略</a></li>
</ul>
</p>
<h1 id="函数参数的默认值">函数参数的默认值</h1>
<h2 id="基本用法">基本用法</h2>
<p><em>ES6</em>之前是不能给函数参数指定默认值的<br>
<em>ES6</em>允许为函数设置默认值，在参数后直接进行赋值</p>
<pre><code class="language-javascript">function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
</code></pre>
<p>参数变量是默认声明的，不能用<code>let</code>和<code>const</code>再次声明</p>
<pre><code class="language-javascript">function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
</code></pre>
<p>使用参数默认值时，函数不能有同名参数</p>
<pre><code class="language-javascript">// 不报错
function foo(x, x, y) {
  // ...
}
// 报错
function foo(x, x, y = 1) {
  // ...
}
// SyntaxError: Duplicate parameter name not allowed in this context
</code></pre>
<p>参数默认值不是传值的，每次都重新计算默认值表达式的值。参数默认值是惰性求值的</p>
<pre><code class="language-javscript">let x = 99;
function foo(p = x + 1) {
  console.log(p);
}
foo() // 100
x = 100;
foo() // 101
</code></pre>
<p>参数p的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100</p>
<h2 id="与解构赋值默认值结合使用">与解构赋值默认值结合使用</h2>
<pre><code class="language-javascript">function foo({x, y = 5}) {
  console.log(x, y);
}
foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
</code></pre>
<p>当函数的参数是一个对象时，参数内的变量才会通过解构赋值生成。如果函数调用时没有提供参数，变量就不会生成，从而报错，通过提供函数参数的默认值就可以避免这种情况</p>
<pre><code class="language-javascript">function foo({x, y = 5} = {}) {
  console.log(x, y);
}
foo() // undefined 5
</code></pre>
<p>如果没有提供参数，函数<code>foo</code>的参数默认为一个空对象</p>
<pre><code class="language-javscript">function fetch(url, { body = '', method = 'GET', headers = {} }) {
  console.log(method);
}
fetch('http://example.com', {})
// &quot;GET&quot;
fetch('http://example.com')
//报错
</code></pre>
<p>虽然对象内的属性设置了默认值，但是并不相当于这个对象设置了默认值，所以传参的时候还是要传一个对象<br>
如果函数<code>fetch</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值</p>
<pre><code class="language-javascript">// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}
// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]
// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]
// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]
// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]
m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
</code></pre>
<h3 id="参数默认值的位置">参数默认值的位置</h3>
<p>定义了参数默认值的参数应该在参数位置的尾部，因为函数在使用的时候，中间的参数是不能省略的，所以默认参数放中间的话必须有一个值传参，那这个值就覆盖了默认参数了，除非显示输入<code>undefined</code></p>
<pre><code class="language-javascript">// 例一
function f(x = 1, y) {
  return [x, y];
}
f() // [1, undefined]
f(2) // [2, undefined]
f(, 1) // 报错
f(undefined, 1) // [1, 1]
// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}
f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
</code></pre>
<h3 id="函数的length属性">函数的length属性</h3>
<p>指定了默认值之后，<code>length</code>属性返回没有指定默认值的参数个数<br>
这是因为<code>length</code>属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入<code>length</code>属性<code>(function(...args) {}).length // 0</code><br>
如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了</p>
<pre><code class="language-javascript">(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
</code></pre>
<h3 id="作用域">作用域</h3>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p>
<pre><code class="language-javascript">var x = 1;
function f(x, y = x) {
  console.log(y);
}
f(2) // 2
</code></pre>
<p>参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code></p>
<pre><code class="language-javscript">let x = 1;
function f(y = x) {
  let x = 2;
  console.log(y);
}
f() // 1
</code></pre>
<p>函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code></p>
<pre><code class="language-javascript">var x = 1;
function foo(x = x) {
  // ...
}
foo() // ReferenceError: x is not defined
</code></pre>
<p>参数<code>x = x</code>形成一个单独作用域。实际执行的是<code>let x = x</code>，由于暂时性死区的原因，这行代码会报错”x 未定义“<br>
如果参数的默认值是一个函数，该函数的作用域也遵守这个规则</p>
<pre><code class="language-javascript">let foo = 'outer';
function bar(func = () =&gt; foo) {
  let foo = 'inner';
  console.log(func());
}
bar(); // outer
</code></pre>
<p>函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。函数参数形成的单独作用域里面，并没有定义变量<code>foo</code>，所以<code>foo</code>指向外层的全局变量<code>foo</code>，因此输出<code>outer</code></p>
<h1 id="rest参数">rest参数</h1>
<p><em>ES6</em>引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中</p>
<pre><code class="language-javascript">function add(...values) {
  let sum = 0;
  for (var val of values) {
    sum += val;
  }
  return sum;
}
add(2, 5, 3) // 10
</code></pre>
<p><code>add</code>函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数<br>
<code>arguments</code>对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用<code>Array.prototype.slice.call</code>先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用<br>
rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错<br>
函数的<code>length</code>属性，不包括 rest 参数</p>
<h1 id="严格模式">严格模式</h1>
<p><em>ES2016</em>规定只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部不能显示设定为严格模式<br>
这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行<br>
两种方法可以规避这种限制</p>
<ul>
<li>设定全局性的严格模式</li>
<li>把函数抱在一个无参数的立即执行函数里面</li>
</ul>
<h1 id="name属性">name属性</h1>
<p>函数的<code>name</code>属性返回函数的函数名<br>
如果将一个匿名函数赋值给一个变量，<em>ES5</em>会返回空字符串，<em>ES6</em>会返回实际的函数名</p>
<pre><code class="language-javascript">var f = function () {};
// ES5
f.name // &quot;&quot;
// ES6
f.name // &quot;f&quot;
</code></pre>
<p>如果将一个具名函数赋值给一个变量，则<em>ES5</em>和<em>ES6</em>的name属性都返回这个具名函数原本的名字<br>
<code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code><br>
<code>bind</code>返回的函数，<code>name</code>属性会加上<code>bound</code>前缀</p>
<pre><code class="language-javascript">(new Function).name // &quot;anonymous&quot;
function foo() {};
foo.bind({}).name // &quot;bound foo&quot;
(function(){}).bind({}).name // &quot;bound &quot;
</code></pre>
<h1 id="箭头函数">箭头函数</h1>
<p>使用=&gt;定义函数<br>
如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分<br>
如果箭头函数的代码块部分多于一条语句，就是用大括号括起来，使用<code>return</code>语句返回<br>
如果箭头函数返回一个对象，必须在对象外加上括号，否则会报错</p>
<pre><code class="language-javascript">// 报错
let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; };
// 不报错
let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });
</code></pre>
<p>特殊情况，虽然可以运行，会得到错误的结果</p>
<pre><code class="language-javascript">let foo = () =&gt; { a: 1 };
foo() // undefined
</code></pre>
<p>原始意图是返回一个对象<code>{ a: 1 }</code>，但是由于引擎认为大括号是代码块，所以执行了一行语句<code>a: 1</code>。这时，<code>a</code>可以被解释为语句的标签，因此实际执行的语句是<code>1;</code>，然后函数就结束了，没有返回值<br>
如果箭头函数只有一行语句，且不需要返回值<code>let fn = () =&gt; void doesNotReturn();</code><br>
箭头函数可以与变量解构结合使用</p>
<pre><code class="language-javascript">const full = ({ first, last }) =&gt; first + ' ' + last;
// 等同于
function full(person) {
  return person.first + ' ' + person.last;
}
</code></pre>
<p>rest 参数与箭头函数结合的例子</p>
<pre><code class="language-javascript">const numbers = (...nums) =&gt; nums;
numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]
const headAndTail = (head, ...tail) =&gt; [head, tail];
headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
</code></pre>
<h2 id="注意">注意</h2>
<ol>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象，与别处不同。箭头函数本身没有<code>this</code>，是直接使用所在对象的<code>this</code></li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替</li>
<li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li>
</ol>
<p><code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的<br>
箭头函数可以让this指向固定化，这种特性很有利于封装回调函数<br>
<code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数<br>
除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code><br>
由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向</p>
<h2 id="不适用场合">不适用场合</h2>
<p>由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数<br>
第一个场合是定义对象的方法，且该方法内部包括<code>this</code></p>
<pre><code class="language-javascript">const cat = {
  lives: 9,
  jumps: () =&gt; {
    this.lives--;
  }
}
</code></pre>
<p><code>cat.jumps()</code>方法是一个箭头函数，这是错误的。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域</p>
<p>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数</p>
<h2 id="嵌套的箭头函数">嵌套的箭头函数</h2>
<p>箭头函数内部还可以再使用箭头函数<br>
箭头函数还有一个功能，就是可以很方便地改写 λ 演算</p>
<h1 id="尾调用优化">尾调用优化</h1>
<p>指某个函数的最后一步是调用另一个函数<br>
以下三种情况，都不属于尾调用</p>
<pre><code class="language-javascript">// 情况一
function f(x){
  let y = g(x);
  return y;
}
// 情况二
function f(x){
  return g(x) + 1;
}
// 情况三
function f(x){
  g(x);
}
</code></pre>
<p>情况一是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码</p>
<pre><code class="language-javascript">function f(x){
  g(x);
  return undefined;
}
</code></pre>
<h2 id="尾调用优化-2">尾调用优化</h2>
<p>函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数B，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）<br>
尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了</p>
<pre><code class="language-javascript">function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();
// 等同于
function f() {
  return g(3);
}
f();
// 等同于
g(3);
</code></pre>
<p>如果函数<code>g</code>不是尾调用，函数f就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧<br>
这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义<br>
注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”</p>
<pre><code class="language-javascript">function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}
</code></pre>
<p>函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code></p>
<h2 id="尾递归">尾递归</h2>
<p>递归非常浪费内存，因为会保存大量的调用帧，容易发生栈溢出错误，所以使用尾递归，栈中只会存在一个调用帧，所以不会发生溢出</p>
<pre><code class="language-javascript">function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}
factorial(5) // 120
</code></pre>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n)<br>
如果改写成尾递归，只保留一个调用记录，复杂度 O(1)</p>
<pre><code class="language-javascript">function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}
factorial(5, 1) // 120
</code></pre>
<h2 id="递归函数的改写">递归函数的改写</h2>
<p>改写函数需要将内部用到的变量，用在return语句上计算的变量，需要转换为函数中的参数。这样的缺点是不够直观，如上面的函数，为什么计算<code>5</code>的阶乘，需要传入两个参数<code>5</code>和<code>1</code><br>
两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数</p>
<pre><code class="language-javascript">function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}
function factorial(n) {
  return tailFactorial(n, 1);
}
factorial(5) // 120
</code></pre>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化</p>
<pre><code class="language-javascript">function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}
const factorial = currying(tailFactorial, 1);
factorial(5) // 120
</code></pre>
<p>第二种方法就简单多了，就是采用 ES6 的函数默认值</p>
<h2 id="严格模式-2">严格模式</h2>
<p><em>ES6</em> 的尾调用优化只在严格模式下开启，正常模式是无效的<br>
这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈</p>
<ul>
<li><code>func.arguments</code>：返回调用时函数的参数</li>
<li><code>func.caller</code>：返回调用当前函数的那个函数</li>
</ul>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效</p>
<pre><code class="language-javascript">function restricted() {
  'use strict';
  restricted.caller;    // 报错
  restricted.arguments; // 报错
}
restricted();
</code></pre>
<h2 id="尾递归优化的实现">尾递归优化的实现</h2>
<p>尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”</p>
<h1 id="函数参数的尾逗号">函数参数的尾逗号</h1>
<p><em>ES2017</em>允许函数最后一个参数有尾逗号<br>
这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了</p>
<h1 id="functionprototypetostring">Function.prototype.toString()</h1>
<p><em>ES2019</em>对函数实例的<code>toString()</code>方法做出修改<br>
<code>toString()</code>方法返回函数代码本身，以前会省略注释和空格<br>
修改后的<code>toString()</code>方法，明确要求返回一摸一样的原始代码</p>
<h1 id="catch命令的参数省略">catch命令的参数省略</h1>
<p><code>try...catch</code>以前明确要求<code>catch</code>命令后面必须跟参数，<em>ES2019</em>允许<code>catch</code>语句省略参数</p>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://greyseid.github.io/post/shu-zhi-de-kuo-zhan/">
                                <h3 class="post-title">
                                    数值的扩展
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">函数参数的默认值</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>
<li><a href="#%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E9%BB%98%E8%AE%A4%E5%80%BC%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8">与解构赋值默认值结合使用</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE">参数默认值的位置</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84length%E5%B1%9E%E6%80%A7">函数的length属性</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#rest%E5%8F%82%E6%95%B0">rest参数</a></li>
<li><a href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">严格模式</a></li>
<li><a href="#name%E5%B1%9E%E6%80%A7">name属性</a></li>
<li><a href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">箭头函数</a>
<ul>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
<li><a href="#%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88">不适用场合</a></li>
<li><a href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">嵌套的箭头函数</a></li>
</ul>
</li>
<li><a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96">尾调用优化</a>
<ul>
<li><a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96-2">尾调用优化</a></li>
<li><a href="#%E5%B0%BE%E9%80%92%E5%BD%92">尾递归</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%B9%E5%86%99">递归函数的改写</a></li>
<li><a href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-2">严格模式</a></li>
<li><a href="#%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0">尾递归优化的实现</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%B0%BE%E9%80%97%E5%8F%B7">函数参数的尾逗号</a></li>
<li><a href="#functionprototypetostring">Function.prototype.toString()</a></li>
<li><a href="#catch%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E7%9C%81%E7%95%A5">catch命令的参数省略</a></li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://greyseid.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
</body>

</html>