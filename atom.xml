<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://greyseid.github.io/</id>
    <title>正义大厅</title>
    <updated>2020-12-20T13:08:29.838Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://greyseid.github.io/"/>
    <link rel="self" href="https://greyseid.github.io/atom.xml"/>
    <subtitle>欢迎来到GREYSEID的自留地</subtitle>
    <logo>https://greyseid.github.io/images/avatar.png</logo>
    <icon>https://greyseid.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 正义大厅</rights>
    <entry>
        <title type="html"><![CDATA[学习Bootstrap——表格]]></title>
        <id>https://greyseid.github.io/post/xue-xi-bootstrap-biao-ge/</id>
        <link href="https://greyseid.github.io/post/xue-xi-bootstrap-biao-ge/">
        </link>
        <updated>2020-12-15T09:49:32.000Z</updated>
        <content type="html"><![CDATA[<p></p>
<p>Bootstrap对html中的表格元素都进行了一定程度上的重构<br>
并且还额外提供了表格样式类来部分自定义表格样式</p>
<p>用于<code>&lt;table&gt;</code>标签的类</p>
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.table</td>
<td>为任意<code>&lt;table&gt;</code>添加基本样式（只有横分隔线）</td>
</tr>
<tr>
<td>.table-striped</td>
<td>在<code>&lt;tbody&gt;</code>中添加斑马条纹（ie8）不支持</td>
</tr>
<tr>
<td>.table-bordered</td>
<td>为所有表格的单元格添加边框</td>
</tr>
<tr>
<td>.table-hover</td>
<td>在<code>&lt;tbody&gt;</code>内的任一行启用鼠标悬停状态</td>
</tr>
<tr>
<td>.table-condensed</td>
<td>让表格更加紧凑（虽然使用了Bootstrap提供的<code>&lt;table&gt;</code>标签已经比原来紧凑了）</td>
</tr>
</tbody>
</table>
<p><code>&lt;tr&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;td&gt;</code></p>
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.active</td>
<td>将悬停的颜色应用在行或单元格中</td>
</tr>
<tr>
<td>.success</td>
<td>将Bootstrap中代表成功的颜色应用到行或单元格中</td>
</tr>
<tr>
<td>.info</td>
<td>将Bootstrap中代表信息的颜色应用到行或单元格中</td>
</tr>
<tr>
<td>.warning</td>
<td>将Bootstrap中代表警告的颜色应用到行或单元格中</td>
</tr>
<tr>
<td>.danger</td>
<td>将Bootstrap中代表危险的颜色应用到行或单元格中</td>
</tr>
</tbody>
</table>
<p>其他的能定义表格类型的类</p>
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.table-bordered</td>
<td>带边框</td>
</tr>
<tr>
<td>.table-condensed</td>
<td>精简表格，行内距减半，更加紧凑</td>
</tr>
<tr>
<td>.table-responsive</td>
<td>响应式表格，让表格水平滚动以适应小型设备，大型设备没区别</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习Bootstrap——代码及其他字体表示]]></title>
        <id>https://greyseid.github.io/post/xue-xi-bootstrap-dai-ma-ji-qi-ta-zi-ti-biao-shi/</id>
        <link href="https://greyseid.github.io/post/xue-xi-bootstrap-dai-ma-ji-qi-ta-zi-ti-biao-shi/">
        </link>
        <updated>2020-12-15T09:27:08.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9B%B4%E5%A4%9A%E5%AE%9E%E4%BE%8B">更多实例</a></li>
</ul>
</p>
<p>有两种方法表达代码<br>
一种是内联的<code>&lt;code&gt;</code>，就相当于一行一行的，会有间隙<br>
一种是<code>&lt;pre&gt;</code>，是块级的，就相当于一个块区域包裹<br>
这两个标签要使用转义字符<code>&amp;lt;</code>和<code>&amp;gt;</code></p>
<h1 id="更多实例">更多实例</h1>
<p><img src="https://greyseid.github.io//post-images/1608024639794.png" alt="" loading="lazy"><br>
基本上都是对标签的重构，基本上样式都有很大变化</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习Bootstrap——排版]]></title>
        <id>https://greyseid.github.io/post/bootstrap-pai-ban/</id>
        <link href="https://greyseid.github.io/post/bootstrap-pai-ban/">
        </link>
        <updated>2020-12-15T07:22:12.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%A0%87%E9%A2%98">标题</a></li>
<li><a href="#%E5%BC%BA%E8%B0%83">强调</a></li>
<li><a href="#%E7%BC%A9%E5%86%99">缩写</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80">地址</a></li>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a></li>
<li><a href="#%E5%88%97%E8%A1%A8">列表</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%A0%B7%E5%BC%8F">其他样式</a></li>
</ul>
</p>
<p>Bootstrap对一些字体相关的元素比如<code>&lt;small&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;h1&gt;</code>等都设置了全新的样式，基本上不用使用class都能使用</p>
<h1 id="标题">标题</h1>
<p>Bootstrap重新定义了<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>的样式<br>
<img src="https://greyseid.github.io//post-images/1608020203430.png" alt="" loading="lazy"><br>
如果使用内联子标题的话，可以使用<code>&lt;small&gt;</code>标签或者是使用.small<br>
使用class=&quot;lead&quot;将获得引导主体副本，是一个更大更粗字体更高行高的文本</p>
<h1 id="强调">强调</h1>
<p>Bootstrap除了重构强调标签<code>&lt;small&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>之外，还增加了一些强调文本的类，类的前缀都为<code>text-****</code></p>
<pre><code class="language-javascript">&lt;small&gt;本行内容是在标签内&lt;/small&gt;&lt;br&gt;
&lt;strong&gt;本行内容是在标签内&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;本行内容是在标签内，并呈现为斜体&lt;/em&gt;&lt;br&gt;
&lt;p class=&quot;text-left&quot;&gt;向左对齐文本&lt;/p&gt;
&lt;p class=&quot;text-center&quot;&gt;居中对齐文本&lt;/p&gt;
&lt;p class=&quot;text-right&quot;&gt;向右对齐文本&lt;/p&gt;
&lt;p class=&quot;text-muted&quot;&gt;本行内容是减弱的&lt;/p&gt;
&lt;p class=&quot;text-primary&quot;&gt;本行内容带有一个 primary class&lt;/p&gt;
&lt;p class=&quot;text-success&quot;&gt;本行内容带有一个 success class&lt;/p&gt;
&lt;p class=&quot;text-info&quot;&gt;本行内容带有一个 info class&lt;/p&gt;
&lt;p class=&quot;text-warning&quot;&gt;本行内容带有一个 warning class&lt;/p&gt;
&lt;p class=&quot;text-danger&quot;&gt;本行内容带有一个 danger class&lt;/p&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://greyseid.github.io//post-images/1608021404784.png" alt="" loading="lazy"></figure>
<h1 id="缩写">缩写</h1>
<p>html提供了<code>&lt;abbr&gt;</code>来用于缩写，只要将鼠标悬停，就能显示完整文本（tittle的文本），Bootstrap提供了.initialism类来使得显示更小的文本</p>
<h1 id="地址">地址</h1>
<p>使用标签<code>&lt;address&gt;</code>来显示联系信息，Bootstrap重构了样式，因为<code>&lt;address&gt;</code>是块元素，所以换行要用<code>&lt;br&gt;</code></p>
<h1 id="引用">引用</h1>
<p>使用<code>&lt;blockquote&gt;</code>标签进行引用，效果就是左边加一条竖线，相当于引用，如果使用.pull-right，则会右对齐，不能使用.text-right，因为使用的时候，如果使用<code>&lt;small&gt;</code>标签，引用会有条横杠，pull-right横杠在文本右边，text-right在文本左边，而且竖线也不见了</p>
<h1 id="列表">列表</h1>
<figure data-type="image" tabindex="2"><img src="https://greyseid.github.io//post-images/1608022482654.png" alt="" loading="lazy"></figure>
<h1 id="其他样式">其他样式</h1>
<figure data-type="image" tabindex="3"><img src="https://greyseid.github.io//post-images/1608024263238.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习Bootstrap——栅格系统]]></title>
        <id>https://greyseid.github.io/post/xue-xi-bootstrap-zha-ge-xi-tong/</id>
        <link href="https://greyseid.github.io/post/xue-xi-bootstrap-zha-ge-xi-tong/">
        </link>
        <updated>2020-12-15T02:46:42.000Z</updated>
        <content type="html"><![CDATA[<p>Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列<br>
我感觉网格就是划定了最小的方块，元素的大小都是由方块决定，因此遇到不同的设备，只要改变方块的大小，那么所有元素的大小也就会改变</p>
<h1 id="什么是网格">什么是网格</h1>
<p>在平面设计中，网格是一种由一系列用于组织内容的相交的直线（垂直的、水平的）组成的结构（通常是二维的）。它广泛应用于打印设计中的设计布局和内容结构。在网页设计中，它是一种用于快速创建一致的布局和有效地使用 HTML 和 CSS 的方法。<br>
简单地说，网页设计中的网格用于组织内容，让网站易于浏览，并降低用户端的负载</p>
<h1 id="什么是-bootstrap-网格系统">什么是 Bootstrap 网格系统</h1>
<p>Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类。<br>
Bootstrap 3 是移动设备优先的，在这个意义上，Bootstrap 代码从小屏幕设备（比如移动设备、平板电脑）开始，然后扩展到大屏幕设备（比如笔记本电脑、台式电脑）上的组件和网格</p>
<h2 id="移动设备优先策略">移动设备优先策略</h2>
<ul>
<li>内容
<ul>
<li>决定什么是最重要的。</li>
</ul>
</li>
<li>布局
<ul>
<li>优先设计更小的宽度。</li>
<li>基础的 CSS 是移动设备优先，媒体查询是针对于平板电脑、台式电脑。</li>
</ul>
</li>
<li>渐进增强
<ul>
<li>随着屏幕大小的增加而添加元素。<br>
响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列<br>
<img src="https://greyseid.github.io//post-images/1608001587842.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="原理">原理</h2>
<ul>
<li>网格系统通过一系列包含内容的行和列来创建页面布局</li>
<li>行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）。</li>
<li>使用行来创建列的水平组。</li>
<li>内容应该放置在列内，且唯有列可以是行的直接子元素。</li>
<li>预定义的网格类，比如 .row 和 .col-xs-4，可用于快速创建网格布局。LESS 混合类可用于更多语义布局。</li>
<li>列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 .rows 上的外边距（margin）取负，表示第一列和最后一列的行偏移。</li>
<li>网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 .col-xs-4。</li>
</ul>
<h1 id="媒体查询">媒体查询</h1>
<p><code>@media</code>作为一个比较特殊的css规则，是网格系统实现的重要组成部分。</p>
<pre><code class="language-javascript">@media screen and (min-width:767px)/*平板尺寸*/
{
    .container{
        /*code*/
    }
}
@media screen and (min-width:991px)/*台式电脑尺寸*/
{
    .container{
        /*code*/
    }
}
</code></pre>
<p><code>@media</code>会适配最适合的一个类<br>
媒体查询有两个部分，先是一个设备规范，然后是一个大小规则</p>
<h1 id="网络选项">网络选项</h1>
<p><img src="https://greyseid.github.io//post-images/1608013423377.png" alt="" loading="lazy"><br>
不同的屏幕分辨率有不同的类前缀，就是class前缀，这是为了让一个元素使用多个类，然后在不同的分辨率中，有不同的布局。也就是说，如果元素只是用一个类的话，如果分辨率比类的要求大，那么就会保持不变，如果是小的话，就会变成一行一列了，排版布局就会出现问题</p>
<h2 id="基本的网格结构">基本的网格结构</h2>
<p>下面是 Bootstrap 网格的基本结构：</p>
<pre><code class="language-javascript">&lt;div class=&quot;container&quot;&gt;
   &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;      
   &lt;/div&gt;
   &lt;div class=&quot;row&quot;&gt;...&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;container&quot;&gt;....
</code></pre>
<h1 id="响应式的列重置">响应式的列重置</h1>
<p>以下实例包含了4个网格，但是我们在小设备浏览时无法确定网格显示的位置。<br>
为了解决这个问题，可以使用 .clearfix class和 响应式实用工具来解决</p>
<pre><code class="language-javascript">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot; &gt;
        &lt;div class=&quot;col-xs-6 col-sm-3&quot; 
            style=&quot;background-color: #dedef8;
            box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;
            &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-xs-6 col-sm-3&quot; 
        style=&quot;background-color: #dedef8;box-shadow: 
        inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;
            &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do 
            eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut 
            enim ad minim veniam, quis nostrud exercitation ullamco laboris 
            nisi ut aliquip ex ea commodo consequat.
            &lt;/p&gt;
            &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do 
            eiusmod tempor incididunt ut. 
            &lt;/p&gt;
        &lt;/div&gt;
 
        &lt;div class=&quot;clearfix visible-xs&quot;&gt;&lt;/div&gt;
 
        &lt;div class=&quot;col-xs-6 col-sm-3&quot; 
        style=&quot;background-color: #dedef8;
        box-shadow:inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;
            &lt;p&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco 
            laboris nisi ut aliquip ex ea commodo consequat. 
            &lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-xs-6 col-sm-3&quot; 
        style=&quot;background-color: #dedef8;box-shadow: 
        inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;
            &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do 
            eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut 
            enim ad minim 
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h1 id="列偏移">列偏移</h1>
<p>.col-xs-* 类不支持偏移，但是它们可以简单地通过使用一个空的单元格来实现该效果，因为不能再缩小了，所以可以随意弄<br>
为了在大屏幕显示器上使用偏移，请使用 .col-md-offset-* 类。这些类会把一个列的左外边距（margin）增加 * 列，其中 * 范围是从 1 到 11。<br>
在下面的实例中，我们有 <div class="col-md-6">..</div>，我们将使用 .col-md-offset-3 class 来居中这个 div</p>
<pre><code class="language-javascript">&lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;Hello, world!&lt;/h1&gt;
    &lt;div class=&quot;row&quot; &gt;
        &lt;div class=&quot;col-md-6 col-md-offset-3&quot; 
        style=&quot;background-color: #dedef8;box-shadow: 
        inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;
            &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing 
            elit.
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h1 id="嵌套列">嵌套列</h1>
<p>在使用.row的元素中，再使用.row，进行嵌套，一行不超过12格</p>
<h1 id="列排序">列排序</h1>
<p>Bootstrap 网格系统另一个完美的特性，就是您可以很容易地以一种顺序编写列，然后以另一种顺序显示列。<br>
您可以很轻易地改变带有 .col-md-push-* 和 .col-md-pull-* 类的内置网格列的顺序，其中 * 范围是从 1 到 11。<br>
在下面的实例中，我们有两列布局，左列很窄，作为侧边栏。我们将使用 .col-md-push-* 和 .col-md-pull-* 类来互换这两列的顺序</p>
<pre><code class="language-javascript">&lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;Hello, world!&lt;/h1&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;p&gt;
            排序前
        &lt;/p&gt;
        &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: #dedef8; box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;
         我在左边
        &lt;/div&gt;
        &lt;div class=&quot;col-md-8&quot; style=&quot;background-color: #dedef8; box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;
         我在右边
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;br&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;p&gt;
            排序后
        &lt;/p&gt;
        &lt;div class=&quot;col-md-4 col-md-push-8&quot; style=&quot;background-color: #dedef8; box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;
         我在左边
        &lt;/div&gt;
        &lt;div class=&quot;col-md-8 col-md-pull-4&quot; style=&quot;background-color: #dedef8; box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;
         我在右边
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>列的偏移相当于增加了空的格，也可以说margin增加了，所以便宜是整行一起偏移的<br>
列排序相当于覆盖吧，如果有一个元素没有移动，那么移动到该元素位置的元素会覆盖，总之，要看清楚位置，列数也相当于坐标，不要重叠了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习bootstrap——CSS概览]]></title>
        <id>https://greyseid.github.io/post/xue-xi-bootstrap-css-gai-lan/</id>
        <link href="https://greyseid.github.io/post/xue-xi-bootstrap-css-gai-lan/">
        </link>
        <updated>2020-12-14T07:56:34.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E4%BC%98%E5%85%88">移动设备优先</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E5%83%8F">响应式图像</a></li>
<li><a href="#%E5%85%A8%E5%B1%80%E6%98%BE%E7%A4%BA-%E6%8E%92%E7%89%88%E5%92%8C%E9%93%BE%E6%8E%A5">全局显示、排版和链接</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%85%A8%E5%B1%80%E6%98%BE%E7%A4%BA">基本的全局显示</a></li>
<li><a href="#%E6%8E%92%E7%89%88">排版</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E6%A0%B7%E5%BC%8F">链接样式</a></li>
</ul>
</li>
<li><a href="#%E9%81%BF%E5%85%8D%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4">避免跨浏览器的不一致</a></li>
<li><a href="#%E5%AE%B9%E5%99%A8container">容器（Container）</a></li>
</ul>
</p>
<p>因为bootstrap使用了html5中的元素和css属性，所以需要加&lt;!doctype html&gt;来表明是html5</p>
<h1 id="移动设备优先">移动设备优先</h1>
<p>我怀疑就是这个所以现在很多app其实加载的页面就是加载的网页，本质上app只是一个浏览器，比如知乎<br>
为了确保移动端看到的页面不会奇形怪状的，要在<head>标签中提供<meta>元数据给浏览器解析，感觉应该是告诉浏览器有不同的分辨率的设备来获取页面<br>
<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code><br>
device-width可以保证正确地加载在屏幕上，initial-scale设置为1.0表示以1:1的比例来显示<br>
也可以添加user-scalable=no禁用缩放，禁用缩放加1:1比例显示，使得如果使用app浏览网页不容易被人认出来</p>
<pre><code class="language-javascript">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, 
                                     initial-scale=1.0, 
                                     maximum-scale=1.0, 
                                     user-scalable=no&quot;&gt;
</code></pre>
<h1 id="响应式图像">响应式图像</h1>
<p><code>&lt;img src=&quot;...&quot; class=&quot;img-responsive&quot; alt=&quot;响应式图像&quot;&gt;</code><br>
因为twitter要失适配移动端，毕竟算是一个社交软件，应该能让更多的人即使没有软件也能在手机上更好地使用，所以比较重视图片之类的</p>
<pre><code class="language-javscript">.img-responsive {
  display: block;
  height: auto;
  max-width: 100%;
}
</code></pre>
<p>图片按比例缩放，以块级元素显示<br>
如果需要让使用了 .img-responsive 类的图片水平居中，请使用 .center-block 类，不要用 .text-center</p>
<h1 id="全局显示-排版和链接">全局显示、排版和链接</h1>
<h2 id="基本的全局显示">基本的全局显示</h2>
<p>body使用margin:0;来移除body外边距</p>
<h2 id="排版">排版</h2>
<p>使用 @font-family-base、 @font-size-base 和 @line-height-base 属性作为排版样式</p>
<h2 id="链接样式">链接样式</h2>
<p>使用属性@link-color设置全局链接颜色</p>
<h1 id="避免跨浏览器的不一致">避免跨浏览器的不一致</h1>
<p>bootstrap使用Normalize.css来建立跨浏览器的一致性</p>
<h1 id="容器container">容器（Container）</h1>
<p>bootstrap3的container class用于包裹页面上的内容，相当于new Vue({})</p>
<pre><code class="language-javascript">&lt;div class=&quot;container&quot;&gt;
  ...
&lt;/div&gt;
</code></pre>
<p>bootstrap中的container</p>
<pre><code class="language-javascript">.container {
   padding-right: 15px;
   padding-left: 15px;
   margin-right: auto;
   margin-left: auto;
}
</code></pre>
<p>由于内边距是固定宽度，默认情况下容器不可嵌套</p>
<pre><code class="language-javascript">.container:before,
.container:after {
  display: table;
  content: &quot; &quot;;
}
</code></pre>
<p>这会产生伪元素。设置 display 为 table，会创建一个匿名的 table-cell 和一个新的块格式化上下文。:before 伪元素防止上边距崩塌，:after 伪元素清除浮动。<br>
如果 conteneditable 属性出现在 HTML 中，由于一些 Opera bug，围绕上述元素创建一个空格。这可以通过使用 content: &quot; &quot; 来修复</p>
<pre><code class="language-javascript">.container:after {
  clear: both;
}
</code></pre>
<p>它创建了一个伪元素，并确保了所有的容器包含所有的浮动元素。<br>
Bootstrap 3 CSS 有一个申请响应的媒体查询，在不同的媒体查询阈值范围内都为 container 设置了max-width，用以匹配网格系统。</p>
<pre><code class="language-javascript">@media (min-width: 768px) {
   .container {
      width: 750px;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[学习bootstrap]]></title>
        <id>https://greyseid.github.io/post/xue-xi-bootstrap/</id>
        <link href="https://greyseid.github.io/post/xue-xi-bootstrap/">
        </link>
        <updated>2020-12-14T07:56:34.000Z</updated>
        <content type="html"><![CDATA[<p>因为bootstrap使用了html5中的元素和css属性，所以需要加&lt;!doctype html&gt;来表明是html5</p>
<h1 id="移动设备优先">移动设备优先</h1>
<p>我怀疑就是这个所以现在很多app其实加载的页面就是加载的网页，本质上app只是一个浏览器，比如知乎<br>
为了确保移动端看到的页面不会奇形怪状的，要在<head>标签中提供<meta>元数据给浏览器解析，感觉应该是告诉浏览器有不同的分辨率的设备来获取页面<br>
<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code><br>
device-width可以保证正确地加载在屏幕上，initial-scale设置为1.0表示以1:1的比例来显示<br>
也可以添加user-scalable=no禁用缩放，禁用缩放加1:1比例显示，使得如果使用app浏览网页不容易被人认出来</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[练习jQuery时遇到的问题]]></title>
        <id>https://greyseid.github.io/post/lian-xi-jquery-shi-yu-dao-de-wen-ti/</id>
        <link href="https://greyseid.github.io/post/lian-xi-jquery-shi-yu-dao-de-wen-ti/">
        </link>
        <updated>2020-12-09T01:25:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="flex布局">flex布局</h1>
<p>使用<code>display:flex</code>时，如果是在width、height前使用的，会失效，要在后面使用</p>
<h1 id="click事件后hover失效">click事件后hover失效</h1>
<p>因为点击事件的优先级比外部引入的css高，所以需要使用<code>!important</code>提升优先级</p>
<h1 id="animate不能用display">animate()不能用display</h1>
<p>使用<code>display:none</code>和<code>display:block</code>失效，还是用<code>show()</code>，<code>hide()</code>代替好一点</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery的学习]]></title>
        <id>https://greyseid.github.io/post/jquery-de-xue-xi/</id>
        <link href="https://greyseid.github.io/post/jquery-de-xue-xi/">
        </link>
        <updated>2020-12-03T06:22:16.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#jquery%E6%A6%82%E8%BF%B0">jQuery概述</a>
<ul>
<li><a href="#javascript%E5%BA%93">JavaScript库</a></li>
<li><a href="#jquery%E7%9A%84%E6%A6%82%E5%BF%B5">jQuery的概念</a>
<ul>
<li><a href="#%E4%BC%98%E7%82%B9">优点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jquery%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">jQuery的基本使用</a></li>
<li><a href="#jquery%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-2">jQuery的基本使用</a>
<ul>
<li><a href="#jquery%E7%9A%84%E9%A1%B6%E7%BA%A7%E5%AF%B9%E8%B1%A1">jQuery的顶级对象$</a></li>
<li><a href="#jquery%E5%AF%B9%E8%B1%A1%E5%92%8Cdom%E5%AF%B9%E8%B1%A1">jQuery对象和DOM对象</a></li>
</ul>
</li>
<li><a href="#this">this</a></li>
<li><a href="#jquery%E5%B8%B8%E7%94%A8api">jQuery常用api</a>
<ul>
<li><a href="#jquery%E9%80%89%E6%8B%A9%E5%99%A8">jQuery选择器</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9%E5%99%A8">基本选择器</a></li>
<li><a href="#jquery%E5%B1%82%E7%BA%A7%E9%80%89%E6%8B%A9%E5%99%A8">jQuery层级选择器</a>
<ul>
<li><a href="#css">css()</a></li>
</ul>
</li>
<li><a href="#jquery%E7%AD%9B%E9%80%89%E9%80%89%E6%8B%A9%E5%99%A8">jQuery筛选选择器</a></li>
<li><a href="#jquery%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8">jQuery属性选择器</a></li>
</ul>
</li>
<li><a href="#jquery%E7%AD%9B%E9%80%89%E6%96%B9%E6%B3%95">jQuery筛选方法*</a></li>
<li><a href="#jquery%E9%87%8C%E9%9D%A2%E7%9A%84%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3">jQuery里面的排他思想</a></li>
<li><a href="#index">index()</a></li>
</ul>
</li>
<li><a href="#jquery%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C">jQuery样式操作</a>
<ul>
<li><a href="#css-2">css</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E7%B1%BB%E6%A0%B7%E5%BC%8F%E6%96%B9%E6%B3%95">设置类样式方法</a>
<ul>
<li><a href="#%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B">链式编程</a></li>
<li><a href="#%E7%B1%BB%E6%93%8D%E4%BD%9C%E4%B8%8Eclassname%E5%8C%BA%E5%88%AB">类操作与className区别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jquery%E6%95%88%E6%9E%9C">jQuery效果</a>
<ul>
<li><a href="#%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%95%88%E6%9E%9C">显示隐藏效果</a>
<ul>
<li><a href="#%E6%98%BE%E7%A4%BA">显示</a></li>
<li><a href="#%E9%9A%90%E8%97%8F">隐藏</a></li>
<li><a href="#%E5%88%87%E6%8D%A2">切换</a></li>
</ul>
</li>
<li><a href="#%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C">滑动效果</a>
<ul>
<li><a href="#%E4%B8%8B%E6%BB%91">下滑</a></li>
<li><a href="#%E4%B8%8A%E6%BB%91">上滑</a></li>
<li><a href="#%E5%88%87%E6%8D%A2-2">切换</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%88%87%E6%8D%A2">事件切换</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E7%94%BB%E9%98%9F%E5%88%97%E5%8F%8A%E5%85%B6%E5%81%9C%E6%AD%A2%E6%8E%92%E9%98%9F%E6%96%B9%E6%B3%95">动画队列及其停止排队方法</a>
<ul>
<li><a href="#%E5%81%9C%E6%AD%A2%E5%8A%A8%E7%94%BB">停止动画</a></li>
</ul>
</li>
<li><a href="#%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA%E6%95%88%E6%9E%9C">淡入淡出效果</a>
<ul>
<li><a href="#%E6%B8%90%E8%BF%9B%E6%96%B9%E5%BC%8F%E8%B0%83%E6%95%B4%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6">渐进方式调整到指定的不透明度</a></li>
<li><a href="#%E6%B7%A1%E5%85%A5">淡入</a></li>
<li><a href="#%E6%B7%A1%E5%87%BA">淡出</a></li>
<li><a href="#%E5%88%87%E6%8D%A2-3">切换</a></li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BBanimate">自定义动画animate</a></li>
</ul>
</li>
<li><a href="#jquery%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C">jQuery属性操作</a>
<ul>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%88%96%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%9B%BA%E6%9C%89%E5%B1%9E%E6%80%A7%E5%80%BCprop">设置或获取元素固有属性值prop()</a>
<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E8%AF%AD%E6%B3%95">获取属性语法</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%AD%E6%B3%95">设置属性语法</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%88%96%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%80%BCattr">设置或获取元素自定义属性值attr()</a>
<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E8%AF%AD%E6%B3%95-2">获取属性语法</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%AD%E6%B3%95-2">设置属性语法</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98data">数据缓存data()</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B">实例</a>
<ul>
<li><a href="#checked%E9%80%89%E6%8B%A9%E5%99%A8">:checked选择器、</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jquery%E5%86%85%E5%AE%B9%E6%96%87%E6%9C%AC%E5%80%BC">jQuery内容文本值</a>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9html%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%8E%9F%E7%94%9Finnerhtml">普通元素内容html()(相当于原生innerHTML)</a></li>
<li><a href="#%E6%99%AE%E9%80%9A%E5%85%83%E7%B4%A0%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9text%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%8E%9F%E7%94%9Finnertext">普通元素文本内容text()（相当于原生innerText）</a></li>
<li><a href="#%E8%A1%A8%E5%8D%95%E7%9A%84%E5%80%BCval%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%8E%9F%E7%94%9Fvalue">表单的值val()（相当于原生value）</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B-2">实例</a>
<ul>
<li><a href="#parents">parents()</a></li>
<li><a href="#tofixed">toFixed()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jquery%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C">jQuery元素操作</a>
<ul>
<li><a href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0">遍历元素</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0">创建元素</a>
<ul>
<li><a href="#%E5%86%85%E9%83%A8%E6%B7%BB%E5%8A%A0">内部添加</a></li>
<li><a href="#%E5%A4%96%E9%83%A8%E6%B7%BB%E5%8A%A0">外部添加</a></li>
</ul>
</li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">删除元素</a></li>
</ul>
</li>
<li><a href="#jquery%E4%BA%8B%E4%BB%B6">jQuery事件</a>
<ul>
<li><a href="#jquery%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C">jQuery事件注册</a>
<ul>
<li><a href="#%E5%8D%95%E4%B8%AA%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C">单个事件注册</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86on%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6">事件处理on()绑定事件</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86off%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6">事件处理off()解绑事件</a></li>
<li><a href="#one">one()</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6trigger">自动触发事件trigger()</a></li>
<li><a href="#jquery%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1">jQuery事件对象</a></li>
</ul>
</li>
<li><a href="#jquery%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95">jQuery其他方法</a>
<ul>
<li><a href="#jquery%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D">jQuery对象拷贝</a></li>
<li><a href="#jquery%E5%A4%9A%E5%BA%93%E5%85%B1%E5%AD%98">jQuery多库共存</a>
<ul>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
</li>
<li><a href="#jquery%E6%8F%92%E4%BB%B6">jQuery插件</a></li>
</ul>
</li>
<li><a href="#jquery%E5%B0%BA%E5%AF%B8-%E4%BD%8D%E7%BD%AE%E6%93%8D%E4%BD%9C">jQuery尺寸、位置操作</a>
<ul>
<li><a href="#jquery%E5%B0%BA%E5%AF%B8">jQuery尺寸</a></li>
<li><a href="#jquery%E4%BD%8D%E7%BD%AE">jQuery位置</a>
<ul>
<li><a href="#offset%E8%AE%BE%E7%BD%AE%E6%88%96%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%81%8F%E7%A7%BB">offset()设置或获取元素偏移</a></li>
<li><a href="#position">position()</a></li>
<li><a href="#scrolltopscrollleft%E8%AE%BE%E7%BD%AE%E6%88%96%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%A2%AB%E5%8D%B7%E5%8E%BB%E7%9A%84%E5%A4%B4%E9%83%A8%E5%92%8C%E5%B7%A6%E4%BE%A7">scrollTop()/scrollLeft()设置或获取元素被卷去的头部和左侧</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="jquery概述">jQuery概述</h1>
<h2 id="javascript库">JavaScript库</h2>
<p>一个封装好特定方法函数的特定集合，是一个js文件，使用原生js代码生成了各种各样功能的js库，提供了很多便捷而又强大的功能</p>
<h2 id="jquery的概念">jQuery的概念</h2>
<p>jQuery提倡写少代码，做多点事情<br>
j：JavaScript；Query：查询js<br>
优化DOM操作、事件处理、动画设计和Ajax交互</p>
<h3 id="优点">优点</h3>
<figure data-type="image" tabindex="1"><img src="https://greyseid.github.io//post-images/1606978056754.png" alt="" loading="lazy"></figure>
<h1 id="jquery的基本使用">jQuery的基本使用</h1>
<p><code>jQuery</code>的入口函数</p>
<pre><code class="language-javascript">//等待页面的DOM元素加载完成再去执行jQuery代码
$(document).ready(
    function(){
        //...code
        //$().function();
    }
)
$(function(){
    //...code
    //$().function();
})
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://greyseid.github.io//post-images/1606978783008.png" alt="" loading="lazy"></figure>
<h1 id="jquery的基本使用-2">jQuery的基本使用</h1>
<h2 id="jquery的顶级对象">jQuery的顶级对象$</h2>
<ol>
<li>$是jQuery的别名</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">是</mi><mi>j</mi><mi>Q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">顶</mi><mi mathvariant="normal">级</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">于</mi><mi>j</mi><mi>s</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">的</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">把</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">利</mi><mi mathvariant="normal">用</mi></mrow><annotation encoding="application/x-tex">是jQuery的顶级对象，相当于js中的window，把元素利用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">是</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">Q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">级</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">于</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">用</span></span></span></span>包装成jQuery对象，就可以调用jQuery方法</li>
</ol>
<h2 id="jquery对象和dom对象">jQuery对象和DOM对象</h2>
<ol>
<li>利用原生js获取的对象就是DOM对象</li>
<li>用jQuery获取的对象就是jQuery对象</li>
<li>jQuery利用$对DOM对象进行包装后产生的对象，以伪数组的形式储存</li>
<li>jQuery对象只能使用jQuery方法，DOM对象则使用原生js属性和方法<code>$('div').style.display='none//error</code></li>
</ol>
<p>DOM对象与jQuery对象是可以相互转换的，原生js有很多属性方法是jQuery中没有封装的，要使用这些，就需要转换才能使用</p>
<ol>
<li>原生DOM转换：<code>$(DOM对象)</code></li>
<li>jQuery对象转换：
<ul>
<li><code>$()[index]</code></li>
<li><code>$().get(index)</code></li>
</ul>
</li>
</ol>
<h1 id="this">this</h1>
<p>在jQuery中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mo>)</mo><mi mathvariant="normal">指</mi><mi mathvariant="normal">向</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi>j</mi><mi>Q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">向</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi></mrow><annotation encoding="application/x-tex">(this)指向的是定义在对象的位置，相当于一个jQuery对象
this相当于指向一个元素，使用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">Q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span></span></span></span>()将其转换为jQuery对象</p>
<h1 id="jquery常用api">jQuery常用api</h1>
<h2 id="jquery选择器">jQuery选择器</h2>
<p>与css选择器类似，加引号即可<br>
菜鸟教程有详细<a href="https://www.runoob.com/jquery/jquery-selectors.html">表格</a></p>
<h3 id="基本选择器">基本选择器</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID选择器</td>
<td>$(&quot;#id&quot;)</td>
<td>获取指定id的元素</td>
</tr>
<tr>
<td>全选选择器</td>
<td>$(&quot;*&quot;)</td>
<td>匹配所有元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>$(&quot;.class&quot;)</td>
<td>获取同一类class的所有元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td>$(&quot;div&quot;)</td>
<td>获取同一类标签的所有元素</td>
</tr>
<tr>
<td>并集选择器</td>
<td>$(&quot;div,p,li&quot;)</td>
<td>获取多个元素</td>
</tr>
<tr>
<td>交集选择器</td>
<td>$(&quot;li.current&quot;)</td>
<td>交集元素</td>
</tr>
</tbody>
</table>
<h3 id="jquery层级选择器">jQuery层级选择器</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>子代选择器</td>
<td>$(&quot;nl&gt;li&quot;)</td>
<td>使用&gt;，获取亲儿子层级的元素，并不会获取孙子层级的元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>$(&quot;ul li&quot;)</td>
<td>使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td>
</tr>
</tbody>
</table>
<h4 id="css">css()</h4>
<p>jQuery对象设置css样式用<code>css(&quot;属性&quot;,&quot;值&quot;)</code><br>
jQuery内部有隐式迭代，把匹配的所有元素都进行遍历循环</p>
<h3 id="jquery筛选选择器">jQuery筛选选择器</h3>
<table>
<thead>
<tr>
<th>语法</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:first</td>
<td>$('li:first)</td>
<td>获取第一个li元素</td>
</tr>
<tr>
<td>:last</td>
<td>$(&quot;li:last&quot;)</td>
<td>获取最后一个li元素</td>
</tr>
<tr>
<td>:eq(index)</td>
<td>$('le:eq(2)')</td>
<td>获取的li元素中，选择索引号为2的元素，索引号index从0开始</td>
</tr>
<tr>
<td>:odd</td>
<td>$('li:odd')</td>
<td>获取到的li元素中，选择索引号为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$('li:even')</td>
<td>获取到的li元素中，选择索引号为偶数的元素</td>
</tr>
</tbody>
</table>
<h3 id="jquery属性选择器">jQuery属性选择器</h3>
<p>jQuery 使用 XPath 表达式来选择带有给定属性的元素。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi mathvariant="normal">&quot;</mi><mo>[</mo><mi>h</mi><mi>r</mi><mi>e</mi><mi>f</mi><mo>]</mo><mi mathvariant="normal">&quot;</mi><mo>)</mo><mi mathvariant="normal">选</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">带</mi><mi mathvariant="normal">有</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi mathvariant="normal">属</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">。</mi></mrow><annotation encoding="application/x-tex">(&quot;[href]&quot;) 选取所有带有 href 属性的元素。
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">&quot;</span><span class="mopen">[</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">]</span><span class="mord">&quot;</span><span class="mclose">)</span><span class="mord cjk_fallback">选</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">带</span><span class="mord cjk_fallback">有</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">。</span></span></span></span>(&quot;[href='#']&quot;) 选取所有带有 href 值等于 &quot;#&quot; 的元素。<br>
<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 11: (&quot;[href!=&#039;#̲&#039;]&quot;) 选取所有带有 hre…'>(&quot;[href!=&#039;#&#039;]&quot;) 选取所有带有 href 值不等于 &quot;#&quot; 的元素。
</span>(&quot;[href$='.jpg']&quot;) 选取所有 href 值以 &quot;.jpg&quot; 结尾的元素。</p>
<h2 id="jquery筛选方法">jQuery筛选方法*</h2>
<table>
<thead>
<tr>
<th>语法</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>parent()</td>
<td>$('li').parent()</td>
<td>查找父级，返回的是最近一级的父级元素</td>
</tr>
<tr>
<td>children(selector)</td>
<td>$('ul').children('li')</td>
<td>相当于$('ul&gt;li')，最近一级（亲儿子）</td>
</tr>
<tr>
<td>find(selector)</td>
<td>$('ul').find('li')</td>
<td>相当于$('ul li')，后代选择器</td>
</tr>
<tr>
<td>siblings(selector)</td>
<td>$('.first').siblings('li')</td>
<td>查找兄弟节点，不包括自己本身</td>
</tr>
<tr>
<td>nextAll([expr])</td>
<td>$('.first').nextAll()</td>
<td>查找当前元素之后所有的同辈元素</td>
</tr>
<tr>
<td>prevAll([expr])</td>
<td>$('.last').prevAll()</td>
<td>查找当前元素之前所有的同辈元素</td>
</tr>
<tr>
<td>hasClass(class)</td>
<td>$('div').hasClass('protected')</td>
<td>检测当前的元素是否含有某个特定的类，如果有，则返回true</td>
</tr>
<tr>
<td>eq(index)</td>
<td>$('li').eq(2)</td>
<td>相当于$('li:eq(2)')，index从0开始</td>
</tr>
</tbody>
</table>
<p>重点：<code>parent()</code>、<code>children()</code>、<code>find()</code>、<code>siblings()</code>、<code>eq()</code><br>
<code>hasClass()</code>只要里面有一个元素有对应class就会返回<code>true</code></p>
<pre><code class="language-javascript">&lt;div id=&quot;div&quot;&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div class='a'&gt;&lt;/div&gt;
&lt;/div&gt;
$(function(){
    cohsole.log($('#div').children('div').hasClass('a'))//true
})
</code></pre>
<h2 id="jquery里面的排他思想">jQuery里面的排他思想</h2>
<p>当前元素设置样式，其余的兄弟元素清除样式<br>
有隐式迭代，省了个for循环之类的</p>
<pre><code class="language-javascript">$(function(){
    $(&quot;button&quot;).click(function(){
        $(this).css(&quot;backgrround-color&quot;,&quot;pink&quot;);
        $(this).siblings(&quot;button&quot;).css(&quot;background-color&quot;,&quot;&quot;);
    })
})
</code></pre>
<h2 id="index">index()</h2>
<p>获取索引号<br>
<code>$(this).index()</code></p>
<h1 id="jquery样式操作">jQuery样式操作</h1>
<h2 id="css-2">css</h2>
<p>参数只写属性名，返回属性值<code>$(this).css(&quot;color&quot;)</code><br>
参数是属性名、属性值，逗号分隔，设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号<br>
参数可以是对象形式，设置多组样式，属性名可以不用加引号，复合属性必须使用驼峰命名法，如果值不是数字，必须加引号</p>
<pre><code class="language-javascript">$(function(){
    $(&quot;div&quot;).css({
        color:&quot;red&quot;,
        backgroundColor:&quot;red&quot;,
        width:100
    });
})
</code></pre>
<h2 id="设置类样式方法">设置类样式方法</h2>
<ol>
<li>添加类<code>$(&quot;div&quot;).addClass(&quot;current&quot;)</code></li>
<li>移除类<code>$(&quot;div&quot;).removeClass(&quot;current&quot;)</code></li>
<li>切换类<code>$(&quot;div&quot;).toggleClass(&quot;current&quot;)</code></li>
</ol>
<p>类名不能跟选择器一样，不能使用<code>.class</code>加点</p>
<h3 id="链式编程">链式编程</h3>
<p><code>$(&quot;div&quot;).addClasss(&quot;current&quot;).siblings().removeClass(&quot;current&quot;)</code><br>
本元素添加类，兄弟元素去除类</p>
<h3 id="类操作与classname区别">类操作与className区别</h3>
<p>原生js中className会覆盖元素原先里面的类名<br>
jQuery里面类操作知识对特定类进行操作，不影响原先的类名</p>
<h1 id="jquery效果">jQuery效果</h1>
<p>动画效果<br>
<img src="https://greyseid.github.io//post-images/1607075550074.png" alt="" loading="lazy"><br>
很明显，由于传参的时候的数值是一定不同的，所以有些函数可以省略各个位置的参数，不必在意后面是否有参数，有些是speed一定要填，后面才能跟其他参数<br>
属于过渡效果，类似与封装了css中的tranform之类的修改方法</p>
<h2 id="显示隐藏效果">显示隐藏效果</h2>
<h3 id="显示">显示</h3>
<p><code>show([speed,[easing],[fn]])</code><br>
参数：<br>
参数都可以省略<br>
speed：使用字符串“slow”、“normal”、“fast”或者数字表示毫秒数来确定显示速度<br>
easing：指定切换效果，默认“swing”，可用参数“linear”<br>
fh：回调函数，动画完成时执行的函数，每个元素执行一次</p>
<pre><code class="language-javascript">$(&quot;p&quot;).show(&quot;slow&quot;);
$(&quot;p&quot;).show(&quot;fast&quot;,function(){
   $(this).text(&quot;Animation Done!&quot;);
 });
$(&quot;p&quot;).show(4000,function(){
   $(this).text(&quot;Animation Done...&quot;);
 });
</code></pre>
<h3 id="隐藏">隐藏</h3>
<p><code>hide([speed,[easing],[fn]])</code><br>
参数使用与显示类似</p>
<pre><code class="language-javascript">$(&quot;p&quot;).hide()
$(&quot;p&quot;).hide(&quot;slow&quot;);
$(&quot;p&quot;).hide(&quot;fast&quot;,function(){
   alert(&quot;Animation Done.&quot;);
 });
</code></pre>
<h3 id="切换">切换</h3>
<p><code>toggle([speed],[easing],[fn])</code><br>
参数使用与显示类似</p>
<pre><code class="language-javascript">$('td).toggle();
$(&quot;p&quot;).toggle(&quot;slow&quot;);
$(&quot;p&quot;).toggle(&quot;fast&quot;,function(){
   alert(&quot;Animation Done.&quot;);
 });
</code></pre>
<h2 id="滑动效果">滑动效果</h2>
<h3 id="下滑">下滑</h3>
<p><code>slideDown([speed,[easing],[fn]])</code><br>
参数使用与显示类似</p>
<pre><code class="language-javascript">$(&quot;.btn2&quot;).click(function(){
  $(&quot;p&quot;).slideDown();
});
$(&quot;p&quot;).slideDown(&quot;slow&quot;);
$(&quot;p&quot;).slideDown(&quot;fast&quot;,function(){
   alert(&quot;Animation Done.&quot;);
 });
</code></pre>
<h3 id="上滑">上滑</h3>
<p><code>slideUp([speed,[easing],[fn]])</code><br>
参数使用与显示类似</p>
<pre><code class="language-javascript">$(&quot;p&quot;).slideUp(&quot;slow&quot;);
$(&quot;p&quot;).slideUp(&quot;fast&quot;,function(){
   alert(&quot;Animation Done.&quot;);
 });
</code></pre>
<h3 id="切换-2">切换</h3>
<p><code>slideToggle([speed],[easing],[fn])</code><br>
参数使用与显示类似</p>
<pre><code class="language-javascript">$(&quot;p&quot;).slideToggle(&quot;slow&quot;);
$(&quot;p&quot;).slideToggle(&quot;fast&quot;,function(){
   alert(&quot;Animation Done.&quot;);
 });
</code></pre>
<h3 id="事件切换">事件切换</h3>
<p><code>hover([over,]out)</code></p>
<ol>
<li>over:鼠标移到元素上要触发的函数（相当于mouseenter）</li>
<li>out:鼠标移出元素要触发的函数（相当于mouseleave）</li>
<li>如果只写一个函数，鼠标经过离开都会触发函数</li>
</ol>
<h2 id="动画队列及其停止排队方法">动画队列及其停止排队方法</h2>
<p>动画或者效果一旦触发就会执行，如果多次触发，就会造成多个动画或者效果排队执行</p>
<h3 id="停止动画">停止动画</h3>
<p><code>stop()</code><br>
<code>stop()</code>方法用于停止动画或效果<br>
注意：<code>stop</code>写到动画或效果的前面，相当于停止结束上一次动画<br>
<code>$(&quot;div&quot;).stop().toggle()</code></p>
<h2 id="淡入淡出效果">淡入淡出效果</h2>
<h3 id="渐进方式调整到指定的不透明度">渐进方式调整到指定的不透明度</h3>
<p><code>fadeTo([[speed],opacity,[easing],[fn]])</code><br>
参数：</p>
<ol>
<li>opacity必须写，取值0-1</li>
<li>speed：三种预定速度字符串：“slow”、“normal”、“fast”，或者使用毫秒数值。必须写</li>
<li>easing：指定切换效果，默认swing，可用linear</li>
<li>fn：回调函数</li>
</ol>
<pre><code class="language-javascript">$(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.66);
$(&quot;p&quot;).fadeTo(&quot;fast&quot;, 0.25, function(){
   alert(&quot;Animation Done.&quot;);
 });
</code></pre>
<h3 id="淡入">淡入</h3>
<p><code>fadeIn([speed],[easing],[fn])</code><br>
参数与之前的作用一样</p>
<pre><code class="language-javascript">$(&quot;p&quot;).fadeIn(&quot;slow&quot;);
(&quot;p&quot;).fadeIn(&quot;fast&quot;,function(){
   alert(&quot;Animation Done.&quot;);
 });
</code></pre>
<h3 id="淡出">淡出</h3>
<p><code>fadeOut([speed],[easing],[fn])</code><br>
参数与之前的作用一样</p>
<pre><code class="language-javascript">$(&quot;p&quot;).fadeOut(&quot;slow&quot;);
$(&quot;p&quot;).fadeOut(&quot;fast&quot;,function(){
   alert(&quot;Animation Done.&quot;);
 });
</code></pre>
<h3 id="切换-3">切换</h3>
<p><code>fadeToggle([speed,[easing],[fn]])</code><br>
参数与之前的作用一样</p>
<pre><code class="language-javascript">$(&quot;p&quot;).fadeToggle(&quot;slow&quot;,&quot;linear&quot;);
$(&quot;p&quot;).fadeToggle(&quot;fast&quot;,function(){
   alert(&quot;Animation Done.&quot;);
 });
</code></pre>
<h2 id="自定义动画animate">自定义动画animate</h2>
<p><code>animate(params,[speed],[easing],[fn])</code><br>
参数：<br>
params：想要修改的样式属性，以对象形式传递，必写，属性名不用带引号，但要使用驼峰命名法，其余参数可以省略<br>
speed：slow、normal、fast、毫秒数值<br>
easing：默认swing，可选linear<br>
fn：回调函数</p>
<h1 id="jquery属性操作">jQuery属性操作</h1>
<h2 id="设置或获取元素固有属性值prop">设置或获取元素固有属性值prop()</h2>
<p>元素固有属性就是元素本身自带的属性，比如&lt;a&gt;元素里的href，比如&lt;input&gt;里的type</p>
<h3 id="获取属性语法">获取属性语法</h3>
<p><code>prop(&quot;属性&quot;)</code></p>
<h3 id="设置属性语法">设置属性语法</h3>
<p><code>prop(&quot;属性&quot;,&quot;属性值&quot;)</code></p>
<h2 id="设置或获取元素自定义属性值attr">设置或获取元素自定义属性值attr()</h2>
<p>用户自己给元素添加属性，我们称之为自定义属性，比如给div添加index=1</p>
<h3 id="获取属性语法-2">获取属性语法</h3>
<p><code>attr(&quot;属性&quot;)//类似原生getAttribute()，css也有attr获取属性值</code></p>
<h3 id="设置属性语法-2">设置属性语法</h3>
<p><code>attr(&quot;属性&quot;,&quot;属性值&quot;)//类似原生setAttribute()</code></p>
<p>该方法可以获取H5自定义属性</p>
<h2 id="数据缓存data">数据缓存data()</h2>
<p>data()方法可以在指定的元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都将被移除</p>
<pre><code class="language-javascript">$(&quot;span&quot;).data(&quot;uname&quot;,&quot;andy&quot;)
$(&quot;span&quot;).data(&quot;uname&quot;)
//data-index
$(&quot;span&quot;).data(&quot;index&quot;)
</code></pre>
<p>获取H5自定义属性，不用写前缀data-，返回的是数字型</p>
<h2 id="实例">实例</h2>
<pre><code class="language-javascript">$(&quot;j-check:checked&quot;).length//复选框被勾选的数量
</code></pre>
<h3 id="checked选择器">:checked选择器、</h3>
<p>:checked 选择器选取所有选中的复选框或单选按钮<br>
<code>$(&quot;:checked&quot;)</code></p>
<h1 id="jquery内容文本值">jQuery内容文本值</h1>
<p>主要针对元素的内容还有表单的值操作</p>
<h2 id="普通元素内容html相当于原生innerhtml">普通元素内容html()(相当于原生innerHTML)</h2>
<p><code>html()//获取元素的内容</code><br>
<code>html(&quot;内容&quot;)//设置元素的内容</code></p>
<h2 id="普通元素文本内容text相当于原生innertext">普通元素文本内容text()（相当于原生innerText）</h2>
<p><code>text()//获取元素的文本内容</code><br>
<code>text(&quot;文本内容&quot;)//设置元素的文本内容</code></p>
<h2 id="表单的值val相当于原生value">表单的值val()（相当于原生value）</h2>
<p><code>$(&quot;input&quot;).val()//获取表单的值</code><br>
<code>$(&quot;input&quot;).val(&quot;123&quot;)//设置表单的值</code></p>
<h2 id="实例-2">实例</h2>
<h3 id="parents">parents()</h3>
<p>返回元素的所有的父亲，会包括html，body，参数可以指定要找的那个祖先元素</p>
<h3 id="tofixed">toFixed()</h3>
<p>四舍五入保留小数位数，参数指定保留几位</p>
<h1 id="jquery元素操作">jQuery元素操作</h1>
<p>主要是遍历、创建、添加、删除元素操作</p>
<h2 id="遍历元素">遍历元素</h2>
<p>jQuery隐式迭代是对同一类元素做了同样的操作。如果想要给同一类元素做不同的操作，就需要用到遍历<br>
<code>$(&quot;div&quot;).each(function(index,doEle){})</code><br>
index是每个元素的索引号，demEle是每个DOM元素对象，不是jQuery对象<br>
<code>$.each(object,function(index,element){})</code><br>
<code>$each()</code>可以用于遍历任何对象，主要用于数据处理，比如数组，对象<br>
index是每个元素的索引号，element是遍历内容</p>
<h2 id="创建元素">创建元素</h2>
<p><code>var li=$(&quot;&lt;li&gt;&lt;/li&gt;&quot;)</code><br>
创建了一个li标签</p>
<h3 id="内部添加">内部添加</h3>
<p><code>element.append(&quot;内容&quot;)</code><br>
<code>$(&quot;ul&quot;).append(li)</code><br>
把内容放在匹配元素内部的后面<br>
<code>$(&quot;ul&quot;).preend(li)</code><br>
把内容放在匹配元素内部的前面</p>
<h3 id="外部添加">外部添加</h3>
<p><code>$(&quot;.test&quot;).after($(&quot;&lt;div&gt;&lt;/div&gt;&quot;))</code><br>
把内容放在匹配元素的后面<br>
<code>$(&quot;.test&quot;).before($(&quot;&lt;div&gt;&lt;/div&gt;&quot;))</code><br>
把内容放在匹配元素的前面</p>
<p>内部添加元素，是父子关系<br>
外部添加元素，是兄弟关系</p>
<h2 id="删除元素">删除元素</h2>
<p><code>element.remove()//删除匹配的元素</code><br>
<code>element.empty()//删除匹配的元素集合中所有的子节点</code><br>
<code>element.html(&quot;&quot;)//清空匹配的元素内容</code></p>
<h1 id="jquery事件">jQuery事件</h1>
<h2 id="jquery事件注册">jQuery事件注册</h2>
<h3 id="单个事件注册">单个事件注册</h3>
<p><code>element.事件(function(){})</code><br>
<code>$(&quot;div&quot;).click(function(){事件处理程序})</code></p>
<h3 id="事件处理on绑定事件">事件处理on()绑定事件</h3>
<p>on()方法优势：<br>
可以绑定多个事件，多个处理事件处理程序</p>
<pre><code class="language-javascript">$(&quot;div&quot;).on({
    mouseover:function(){},
    mouseout:function(){}
})
</code></pre>
<p>事件处理程序相同</p>
<pre><code class="language-javascript">$(&quot;div&quot;).on(&quot;mouseover mouseout&quot;,function(){})
</code></pre>
<p>优势：<br>
可以事件委派操作。事件委派的定义是，把原来加给子元素身上的<br>
事件绑定在父元素身上，把事件委派个父元素。类似于vue的组件，子组件的事件可以向上传递给父组件，父组件监听子组件的事件</p>
<pre><code class="language-javascript">$(&quot;ul&quot;).on(&quot;click&quot;,&quot;li&quot;,function(){//绑定在ul身上，触发是用li
    alert(&quot;hi&quot;);
});
</code></pre>
<p>动态创建元素，click()没法绑定事件，on()可以给动态生成的元素绑定事件</p>
<pre><code class="language-javscript">$(&quot;ol&quot;).on(&quot;click&quot;,&quot;li&quot;,function(){});
var li=$(&quot;&lt;li&gt;&lt;/li&gt;&quot;)
$(&quot;ol&quot;).append(li);
</code></pre>
<h2 id="事件处理off解绑事件">事件处理off()解绑事件</h2>
<p><code>$(&quot;div&quot;).off()</code><br>
解绑所有事件</p>
<p><code>$(&quot;div&quot;).off(&quot;click&quot;)</code><br>
解除点击事件</p>
<p><code>$(&quot;ul&quot;).off(&quot;click&quot;,&quot;li&quot;)</code><br>
解除事件委托</p>
<h2 id="one">one()</h2>
<p>写法与on()一样，但只触发一次</p>
<h2 id="自动触发事件trigger">自动触发事件trigger()</h2>
<p>有些事件希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发</p>
<pre><code class="language-javascript">element.click()//第一种简写形式
element.trigger()//第二种自动触发模式
$(&quot;p&quot;).on(&quot;click&quot;,function(){
    alert(&quot;hi~&quot;);
});
$(&quot;p&quot;).trigger(&quot;click&quot;);//此时自动触发点击事件，不需要鼠标点击，会触发元素默认行为，用了focus之后光标会在框里闪，triggerHandler()不会
element.triggerHandler(type)//第三种自动触发模式，不会触发元素默认行为
</code></pre>
<h2 id="jquery事件对象">jQuery事件对象</h2>
<p>事件被触发就会有事件对象产生<br>
<code>element.on(events,[selector],function(event){})</code><br>
阻止默认行为：event.preventDefault()或者return false<br>
阻止冒泡：event.stopPropagation()</p>
<h1 id="jquery其他方法">jQuery其他方法</h1>
<h2 id="jquery对象拷贝">jQuery对象拷贝</h2>
<p>如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用<code>$.extend()</code>方法<br>
<code>$.extend([deep],target,object1,[objectN])</code><br>
deep：如果设为true为深拷贝，默认为false浅拷贝<br>
target：要拷贝的目标对象<br>
object1：待拷贝到第一个对象的对象<br>
浅拷贝：把原来对象里面复杂数据类型地址拷贝给目标对象<br>
深拷贝：完全克隆，拷贝的是对象的数据而不是地址，修改不会影响其他对象，如果复制时对象内有不冲突的属性，会进行合并<br>
拷贝的时候，如果键值也是一个对象，那么其实只是拷贝了一个地址，修改这个会影响那个</p>
<h2 id="jquery多库共存">jQuery多库共存</h2>
<p>jQuery使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">作</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">随</mi><mi mathvariant="normal">着</mi><mi>j</mi><mi>Q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">流</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi>j</mi><mi>s</mi><mi mathvariant="normal">库</mi><mi mathvariant="normal">也</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi></mrow><annotation encoding="application/x-tex">作为标示符，随着jQuery的流行，其他js库也可能使用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">随</span><span class="mord cjk_fallback">着</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">Q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">流</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">库</span><span class="mord cjk_fallback">也</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span></span></span></span>作为标识符，这样一起使用可能会发生冲突</p>
<h3 id="解决方案">解决方案</h3>
<ol>
<li>把$统一使用jQuery</li>
<li>自定义<code>var i=$.noConflict()</code></li>
</ol>
<h2 id="jquery插件">jQuery插件</h2>
<p>jQuery功能有限，实现更复杂功能可以使用jQuery插件<br>
常用网站：<br>
<img src="https://greyseid.github.io//post-images/1607413869488.png" alt="" loading="lazy"></p>
<h1 id="jquery尺寸-位置操作">jQuery尺寸、位置操作</h1>
<h2 id="jquery尺寸">jQuery尺寸</h2>
<p><code>width(300)//设置宽度为300</code></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>width()/height()</td>
<td>取得匹配元素怒宽度和高度值 只算width/width</td>
</tr>
<tr>
<td>innerWidth()/innerHeight()</td>
<td>取得匹配元素宽度和高度值包括padding</td>
</tr>
<tr>
<td>outerWidth()/outerHeight()</td>
<td>取得匹配元素宽度和高度值包括padding、border</td>
</tr>
<tr>
<td>outerWidth(true)/outerHeight(true)</td>
<td>取得匹配元素宽度和高度值包括padding、border、margin</td>
</tr>
</tbody>
</table>
<p>括号为空，则获取相应值，返回数字型<br>
参数为数字，设置尺寸，可以不用加单位</p>
<h2 id="jquery位置">jQuery位置</h2>
<p>位置方法：<code>offset()</code>、<code>position()</code>、<code>scrollTop()</code>/<code>scrollLeft()</code></p>
<h3 id="offset设置或获取元素偏移">offset()设置或获取元素偏移</h3>
<p>offset()方法设置或返回被选元素相对于文档的偏移坐标，跟父级没关系<br>
返回的是一个对象<code>{top: ,left: }</code></p>
<pre><code class="language-javascript">$(.son).offset({
    top:200,
    left:200
})
</code></pre>
<p>加了定位position还是一样的返回结果</p>
<h3 id="position">position()</h3>
<p>获取距离带有定位父级位置position，如果没有带有定位的父级，以文档为准<br>
使用方法效果与offset()一致，但是<code>position()</code>不能用来设置元素偏移，只能获取</p>
<h3 id="scrolltopscrollleft设置或获取元素被卷去的头部和左侧">scrollTop()/scrollLeft()设置或获取元素被卷去的头部和左侧</h3>
<p><code>scrollTop()</code>方法设置或返回被元素卷去的头部<br>
<code>scrollLeft()</code>方法设置或返回被元素卷去的左部<br>
设置参数就是转到指定位置</p>
<p>可以使用animate的scrollTop属性做出过渡效果<br>
元素才能做动画，文档不行</p>
<pre><code class="language-javascript">$(&quot;body,html&quot;).stop().animate({
    scrollTop:0
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对象的扩展]]></title>
        <id>https://greyseid.github.io/post/dui-xiang-de-kuo-zhan/</id>
        <link href="https://greyseid.github.io/post/dui-xiang-de-kuo-zhan/">
        </link>
        <updated>2020-11-24T09:03:36.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E6%B4%81%E8%A1%A8%E7%A4%BA%E6%B3%95">属性的简洁表示法</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F">属性名表达式</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E7%9A%84name%E5%B1%9E%E6%80%A7">方法的name属性</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7%E5%92%8C%E9%81%8D%E5%8E%86">属性的可枚举性和遍历</a>
<ul>
<li><a href="#%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7">可枚举性</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86">属性的遍历</a></li>
</ul>
</li>
<li><a href="#super%E5%85%B3%E9%94%AE%E5%AD%97">super关键字</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">对象的扩展运算符</a>
<ul>
<li><a href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">扩展运算符</a></li>
</ul>
</li>
<li><a href="#%E9%93%BE%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6">链判断运算符</a></li>
<li><a href="#null%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6">Null判断运算符</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95">对象的新增方法</a>
<ul>
<li><a href="#objectis">Object.is()</a></li>
<li><a href="#objectassign">Object.assign()</a></li>
<li><a href="#objectgetownpropertydescriptors">Object.getOwnPropertyDescriptors()</a></li>
<li><a href="#__proto__%E5%B1%9E%E6%80%A7obiectsetprototypeofobjectgetprototypeof">__proto__属性，Obiect.setPrototypeOf()，Object.getPrototypeOf()</a>
<ul>
<li><a href="#__proto__%E5%B1%9E%E6%80%A7">__proto__属性</a></li>
<li><a href="#objectsetprototypeof">Object.setPrototypeOf()</a></li>
<li><a href="#objectgetprototypeof">Object.getPrototypeOf</a></li>
</ul>
</li>
<li><a href="#objectkeysobjectvaluesobjectentries">Object.keys()，Object.values()，Object.entries()</a>
<ul>
<li><a href="#objectkeys">Object.keys()</a></li>
<li><a href="#objectvalues">Object.values()</a></li>
<li><a href="#objectentries">Object.entries()</a></li>
</ul>
</li>
<li><a href="#objectfromentries">Object.fromEntries()</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="属性的简洁表示法">属性的简洁表示法</h1>
<p><em>ES6</em>允许在大括号内直接写入变量和函数作为对象的属性和方法</p>
<pre><code class="language-javascript">const foo = 'bar';
const baz = {foo};
baz // {foo: &quot;bar&quot;}
// 等同于
const baz = {foo: foo};
</code></pre>
<p>上面代码中，变量foo直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值</p>
<pre><code class="language-javascript">function f(x, y) {
  return {x, y};
}
// 等同于
function f(x, y) {
  return {x: x, y: y};
}
f(1, 2) // Object {x: 1, y: 2}
</code></pre>
<p>方法简写</p>
<pre><code class="language-javascript">const o = {
  method() {
    return &quot;Hello!&quot;;
  }
};
// 等同于
const o = {
  method: function() {
    return &quot;Hello!&quot;;
  }
};
</code></pre>
<p>简写的对象方法不能用作构造函数，会报错。</p>
<pre><code class="language-javascript">const obj = {
  f() {
    this.foo = 'bar';
  }
};
new obj.f() // 报错
</code></pre>
<p>上面代码中，f是一个简写的对象方法，所以obj.f不能当作构造函数使用。</p>
<h1 id="属性名表达式">属性名表达式</h1>
<p><em>JavaScript</em>定义对象的属性</p>
<pre><code class="language-javascript">//方法一
obj.foo=true;
//方法二
obj['a'+'bc']=123;
</code></pre>
<p>上述代码中，方法一使用标识符作为属性名，方法二使用表达式作为属性名<br>
如果使用大括号定义属性名，在ES5中只能使用方法一，而在ES6中，可以用方法二，即把表达式放在方括号内</p>
<pre><code class="language-javascript">let propKey='foo';
let obj={
    [propKey]:true,
    ['a'+'bc']:123
};
obj['abc']//123

let lastWord = 'last word';
const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};
a['first word'] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a['last word'] // &quot;world&quot;

const obj={
  ['a'+'bc']:12,
  [hi],
}
//Uncaught SyntaxError: Unexpected token ','
//Uncaught ReferenceError: here is not defined
</code></pre>
<p>表达式还可以用于定义方法名</p>
<pre><code class="language-javascript">let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};
obj.hello() // hi
</code></pre>
<p>属性名表达式与简洁表示法，不能同时使用，会报错</p>
<pre><code class="language-javascript">// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };
// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
</code></pre>
<p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心</p>
<pre><code class="language-javascript">const keyA = {a: 1};
const keyB = {b: 2};
const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};
myObject // Object {[object Object]: &quot;valueB&quot;}
</code></pre>
<p>上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性</p>
<h1 id="方法的name属性">方法的name属性</h1>
<p>函数的<code>name</code>属性，返回函数名，对象方法也是函数，所以也有<code>name</code>属性<br>
如果对象的方法使用了取值函数<code>getter</code>和存值函数<code>setter</code>，则<code>name</code>属性不会返回方法的名字，因为该属性不是在该方法上，而是在该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code></p>
<pre><code class="language-javascript">const obj = {
  get foo() {},
  set foo(x) {}
};
obj.foo.name
// TypeError: Cannot read property 'name' of undefined
const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');
descriptor.get.name // &quot;get foo&quot;
descriptor.set.name // &quot;set foo&quot;
</code></pre>
<p>特殊情况：</p>
<ul>
<li><code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字</li>
<li><code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code></li>
</ul>
<pre><code class="language-javascript">(new Function()).name // &quot;anonymous&quot;
var doSomething = function() {
  // ...
};
doSomething.bind().name // &quot;bound doSomething&quot;
</code></pre>
<p>如果对象的方法是一个Symbol值，那么<code>name</code>属性返回的是这个Symbol的描述</p>
<pre><code class="language-javascript">const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // &quot;[description]&quot;
obj[key2].name // &quot;&quot;
</code></pre>
<h1 id="属性的可枚举性和遍历">属性的可枚举性和遍历</h1>
<h2 id="可枚举性">可枚举性</h2>
<p>对象的每个属性都有一个描述对象，用来控制该属性的行为<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象</p>
<pre><code class="language-javascript">let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
</code></pre>
<p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性<br>
目有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性</p>
<ul>
<li><code>for...in</code>循环：之遍历自身的和继承的可枚举的属性</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名</li>
<li><code>JSON.stringify()</code>：只串行化对象自身可枚举的属性</li>
<li><code>Object.assign()</code>：忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性</li>
</ul>
<p><code>for...in</code>会返回继承的属性，其他三个方法会忽略继承的属性，只处理对象自身的属性。引入<code>enumerable</code>就是为了规避<code>for...in</code>，不然所有内部属性和方法都会被遍历到<br>
所有Class的原型的方法都是不可枚举的</p>
<h2 id="属性的遍历">属性的遍历</h2>
<ol>
<li>for...in<br>
<code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li>
<li>Object.keys(obj)<br>
<code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li>
<li>Object.getOwnPropertyNames(obj)<br>
<code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li>
<li>Object.getOwnPropertySymbols(obj)<br>
<code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名</li>
<li>Reflect.ownKeys(obj)<br>
<code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li>
</ol>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列</li>
</ul>
<h1 id="super关键字">super关键字</h1>
<p><code>this</code>关键字总是指向函数所在的当前对象，指函数运行时所在的地方。<em>ES6</em>新增了一个<code>super</code>关键字，指向当前对象的原型对象</p>
<pre><code class="language-javascript">const proto = {
  foo: 'hello'
};
const obj = {
  foo: 'world',
  find() {
    return super.foo;
  }
};
Object.setPrototypeOf(obj, proto);
obj.find() // &quot;hello&quot;
</code></pre>
<p><code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错<br>
<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）</p>
<pre><code class="language-javascript">const proto = {
  x: 'hello',
  foo() {
    console.log(this.x);
  },
};
const obj = {
  x: 'world',
  foo() {
    super.foo();
  }
}
Object.setPrototypeOf(obj, proto);
obj.foo() // &quot;world&quot;
</code></pre>
<p><code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code></p>
<h1 id="对象的扩展运算符">对象的扩展运算符</h1>
<p><em>ES2018</em>将...引入了对象</p>
<h2 id="解构赋值">解构赋值</h2>
<p>对象的结构赋值用于对一个对象取值，用于将目标对象身上的所有可遍历的未被读取的对象赋值到指定对象上，所有的键值对都会拷贝到新对象上</p>
<pre><code class="language-javascript">let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
</code></pre>
<p>结构赋值要求等号右边是一个对象，如果等号右边时<code>undefined</code>或<code>null</code>，就会报错，因为他们无法转换为对象<br>
解构赋值必须是最后一个参数，否则报错</p>
<pre><code class="language-javascript">let { ...x, y, z } = someObject; // 句法错误
let { x, ...y, ...z } = someObject; // 句法错误
</code></pre>
<p>解构赋值的复制是浅复制，如果一个键的值是一个复合类型的值（数组、对象、函数），那么解构赋值复制的是这个值的引用而不是副本。相当于复制了这个值的地址，修改这个值，复制之后的值，显示的化会显示修改后的值</p>
<pre><code class="language-javascript">let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2
</code></pre>
<p>扩展运算符的解构赋值，不能复制继承自原型对象的属性</p>
<pre><code class="language-javascript">let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let { ...o3 } = o2;
o3 // { b: 2 }
o3.a // undefined
</code></pre>
<p>对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性</p>
<pre><code class="language-javascript">const o = Object.create({ x: 1, y: 2 });
o.z = 3;
let { x, ...newObj } = o;
let { y, z } = newObj;
x // 1
y // undefined
z // 3
</code></pre>
<p>变量<code>x</code>是单纯的解构赋值，所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量<code>z</code>可以赋值成功，变量y取不到值。<em>ES6</em> 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错</p>
<pre><code class="language-javascript">let { x, ...{ y, z } } = o;
// SyntaxError: ... must be followed by an identifier in declaration contexts
</code></pre>
<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作</p>
<pre><code class="language-javascript">function baseFunction({ a, b }) {
  // ...
}
function wrapperFunction({ x, y, ...restConfig }) {
  // 使用 x 和 y 参数进行操作
  // 其余参数传给原始函数
  return baseFunction(restConfig);
}
</code></pre>
<p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为</p>
<h2 id="扩展运算符">扩展运算符</h2>
<p>对象的扩展运算符...用于取出参数对象的所有可遍历属性，拷贝到当前对象中</p>
<pre><code class="language-javascript">let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
</code></pre>
<p>由于数组是特殊的对象，所以对象的扩展运算符可以使用数组</p>
<pre><code class="language-javascript">let foo = { ...['a', 'b', 'c'] };
foo
// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}
</code></pre>
<p>如果扩展运算符后面是一个空对象，则没有任何效果</p>
<pre><code class="language-javascript">{...{}, a: 1}
// { a: 1 }
</code></pre>
<p>如果扩展运算符后面不是对象，则自动转换为对象</p>
<pre><code class="language-javascript">// 等同于 {...Object(1)}
{...1} // {}
</code></pre>
<p>扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象</p>
<pre><code class="language-javascript">// 等同于 {...Object(true)}
{...true} // {}
// 等同于 {...Object(undefined)}
{...undefined} // {}
// 等同于 {...Object(null)}
{...null} // {}
</code></pre>
<p>如果扩展运算符后面是字符串，它会自动转换成一个类似数组的对象，返回一个空对象。可能是由于数组有一个Iterator，所以能这么转换</p>
<pre><code class="language-javscript">{...'hello'}
// {0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;}
</code></pre>
<p>对象的扩展运算符等同于使用Object.assign()方法</p>
<pre><code class="language-javascript">let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);
</code></pre>
<p>只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法</p>
<pre><code class="language-javascript">// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};
// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);
// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
</code></pre>
<p>写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三<br>
扩展运算符可以用于合并两个对象</p>
<pre><code class="language-javscript">let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
</code></pre>
<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<pre><code class="language-javascript">let aWithOverrides = { ...a, x: 1, y: 2 };
// 等同于
let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
// 等同于
let x = 1, y = 2, aWithOverrides = { ...a, x, y };
// 等同于
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
</code></pre>
<pre><code class="language-javascript">let newVersion = {
  ...previousVersion,
  name: 'New Name' // Override the name property
};
</code></pre>
<p>上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象<br>
如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<pre><code class="language-javascript">let aWithDefaults = { x: 1, y: 2, ...a };
// 等同于
let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);
// 等同于
let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);
</code></pre>
<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p>
<pre><code class="language-javascript">const obj = {
  ...(x &gt; 1 ? {a: 1} : {}),
  b: 2,
};
</code></pre>
<p>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</p>
<pre><code class="language-javascript">let a = {
  get x() {
    throw new Error('not throw yet');
  }
}
let aWithXGetter = { ...a }; // 报错
</code></pre>
<p>上面例子中，取值函数get在扩展a对象时会自动执行，导致报错</p>
<h1 id="链判断运算符">链判断运算符</h1>
<p>如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取<code>message.body.user.firstName</code>，安全的写法是写成下面这样</p>
<pre><code class="language-javascript">// 错误的写法
const  firstName = message.body.user.firstName;
// 正确的写法
const firstName = (message
  &amp;&amp; message.body
  &amp;&amp; message.body.user
  &amp;&amp; message.body.user.firstName) || 'default';
</code></pre>
<p><code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值<br>
三元运算符<code>?:</code>也常用于判断对象是否存在</p>
<pre><code class="language-javascript">const fooInput = myForm.querySelector('input[name=foo]')
const fooValue = fooInput ? fooInput.value : undefined
</code></pre>
<p>上面例子中，必须先判断<code>fooInput</code>是否存在，才能读取<code>fooInput.value</code><br>
这样的层层判断非常麻烦，因此<em>ES2020</em>引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法</p>
<pre><code class="language-javascript">const firstName = message?.body?.user?.firstName || 'default';
const fooValue = myForm.querySelector('input[name=foo]')?.value
</code></pre>
<p>下面是判断对象方法是否存在，如果存在就立即执行的例子</p>
<pre><code class="language-javascript">iterator.return?.()
</code></pre>
<p>上面代码中，<code>iterator.return</code>如果有定义，就会调用该方法，否则<code>iterator.return</code>直接返回<code>undefined</code>，不再执行<code>?.</code>后面的部分<br>
链判断运算符有三种用法</p>
<ul>
<li><code>obj?.prop</code> // 对象属性</li>
<li><code>obj?.[expr]</code>// 同上</li>
<li><code>func?.(...args)</code> // 函数或对象方法的调用</li>
</ul>
<p><code>let hex = &quot;#C0FFEE&quot;.match(/#([A-Z]+)/i)?.[1];</code>字符串的<code>match()</code>方法，如果没有发现匹配会返回<code>null</code>，如果发现匹配会返回一个数组，返回数组的第二个，<code>?.</code>运算符起到了判断作用<br>
使用这个运算符，有几个注意点</p>
<ol>
<li>短路机制<br>
<code>?.</code>运算符相当于一种短路机制，只要不满足条件，就不再往下执行。<pre><code class="language-javascript">a?.[++x]
// 等同于
a == null ? undefined : a[++x]
</code></pre>
上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，那么<code>x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值</li>
<li>delete运算符<pre><code class="language-javascript"> delete a?.b
 // 等同于
 a == null ? undefined : delete a.b
</code></pre>
上面代码中，如果a是undefined或null，会直接返回undefined，而不会进行delete运算</li>
<li>括号的影响<br>
如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响<pre><code class="language-javascript">(a?.b).c
// 等价于
(a == null ? undefined : a.b).c
</code></pre>
上面代码中，?.对圆括号外部没有影响，不管a对象是否存在，圆括号后面的.c总是会执行</li>
<li>报错场合<br>
以下写法是禁止的，会报错。<pre><code class="language-javascript">// 构造函数
new a?.()
new a?.b()
// 链判断运算符的右侧有模板字符串
a?.`{b}`
a?.b`{c}`
// 链判断运算符的左侧是 super
super?.()
super?.foo
// 链运算符用于赋值运算符左侧
a?.b = c
</code></pre>
一般来说，使用?.运算符的场合，不应该使用圆括号</li>
<li>右侧不得为十进制数值<br>
为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数</li>
</ol>
<h1 id="null判断运算符">Null判断运算符</h1>
<p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值</p>
<pre><code class="language-javascript">const headerText = response.settings.headerText || 'Hello, world!';
const animationDuration = response.settings.animationDuration || 300;
const showSplashScreen = response.settings.showSplashScreen || true;
</code></pre>
<p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效<br>
为了避免这种情况，ES2020 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值</p>
<pre><code class="language-javascript">const headerText = response.settings.headerText ?? 'Hello, world!';
const animationDuration = response.settings.animationDuration ?? 300;
const showSplashScreen = response.settings.showSplashScreen ?? true;
</code></pre>
<p>默认值只有在左侧属性值为null或undefined时，才会生效<br>
这个运算符的一个目的，就是跟链判断运算符<code>?.</code>配合使用，为<code>null</code>或<code>undefined</code>的值设置默认值<code>const animationDuration = response.settings?.animationDuration ?? 300;</code><br>
<code>??</code>有一个运算优先级问题，它与<code>&amp;&amp;</code>和<code>||</code>的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错</p>
<h1 id="对象的新增方法">对象的新增方法</h1>
<h2 id="objectis">Object.is()</h2>
<p>ES5比较两个值是否相等只有<code>==</code>和<code>===</code>，它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等<br>
<em>ES6</em>部署了这种方法，<code>Object.is()</code>用来比较两个值是否严格相等，与<code>===</code>的行为基本一致</p>
<pre><code class="language-javascript">Object.is('foo', 'foo')
// true
Object.is({}, {})
// false
</code></pre>
<p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身</p>
<pre><code class="language-javascript">+0 === -0 //true
NaN === NaN // false
Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre>
<h2 id="objectassign">Object.assign()</h2>
<p><code>Object.assign()</code>方法用于对象的合并，将源对象的所有可枚举属性复制到目标对象</p>
<pre><code class="language-javascript">const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre>
<p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性<br>
如果只有一个参数，Object.assign()会直接返回该参数<br>
如果该参数不是对象，则会先转成对象，然后返回<br>
由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错<br>
如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错<br>
其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果<br>
<code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）<br>
属性名为 Symbol 值的属性，也会被<code>Object.assign()</code>拷贝<br>
注意点</p>
<ol>
<li>浅拷贝<br>
<code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用</li>
<li>同名属性的替换<br>
对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加</li>
</ol>
<pre><code class="language-javascript">const target = { a: { b: 'c', d: 'e' } }
const source = { a: { b: 'hello' } }
Object.assign(target, source)
// { a: { b: 'hello' } }
</code></pre>
<p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>{ a: { b: 'hello', d: 'e' } }</code>的结果。这通常不是开发者想要的，需要特别小心<br>
3. 数组的处理<br>
<code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象<code>Object.assign([1, 2, 3], [4, 5])// [4, 5, 3]</code><br>
4. 取值函数的处理<br>
<code>Object.assign()</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制</p>
<pre><code class="language-javascript">const source = {
  get foo() { return 1 }
};
const target = {};
Object.assign(target, source)
// { foo: 1 }
</code></pre>
<h2 id="objectgetownpropertydescriptors">Object.getOwnPropertyDescriptors()</h2>
<p>返回指定对象所有自身属性（非继承属性）的描述对象<br>
引入的目的是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>和<code>set</code>属性的问题</p>
<pre><code class="language-javascript">const source = {
  set foo(value) {
    console.log(value);
  }
};
const target1 = {};
Object.assign(target1, source);
Object.getOwnPropertyDescriptor(target1, 'foo')
// { value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true }
</code></pre>
<p><code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法<br>
<code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝<br>
<code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝</p>
<pre><code class="language-javascript">const clone = Object.create(Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj));
// 或者
const shallowClone = (obj) =&gt; Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
</code></pre>
<p><code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象</p>
<pre><code class="language-javascript">const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123,
  })
);
</code></pre>
<h2 id="__proto__属性obiectsetprototypeofobjectgetprototypeof">__proto__属性，Obiect.setPrototypeOf()，Object.getPrototypeOf()</h2>
<h3 id="__proto__属性">__proto__属性</h3>
<p>用来读取或设置当前对象的原型对象</p>
<pre><code class="language-javascript">// es5 的写法
const obj = {
  method: function() { ... }
};
obj.__proto__ = someOtherObj;
// es6 的写法
var obj = Object.create(someOtherObj);
obj.method = function() { ... };
</code></pre>
<p>该属性不是一个标准，但是被浏览器广泛支持，所以可以部署这个属性，如果想要通用的话，最好使用<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替</p>
<h3 id="objectsetprototypeof">Object.setPrototypeOf()</h3>
<p>作用与<code>__proto__</code>相同，用来设置一个对象的原型对象，返回参数对象本身</p>
<pre><code class="language-javascript">// 格式
Object.setPrototypeOf(object, prototype)
// 用法
const o = Object.setPrototypeOf({}, null);
//等同于
function setPrototypeOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
</code></pre>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果<br>
由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错</p>
<h3 id="objectgetprototypeof">Object.getPrototypeOf</h3>
<p>读取一个对象的原型函数<code>Object.getPrototypeOf(obj);</code></p>
<pre><code class="language-javascript">function Rectangle() {
  // ...
}
const rec = new Rectangle();
Object.getPrototypeOf(rec) === Rectangle.prototype
// true
Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
</code></pre>
<p>如果参数不是对象，会被自动转为对象<br>
如果参数不是对象，会被自动转为对象</p>
<h2 id="objectkeysobjectvaluesobjectentries">Object.keys()，Object.values()，Object.entries()</h2>
<h3 id="objectkeys">Object.keys()</h3>
<p>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键名</p>
<pre><code class="language-javascript">var obj = { foo: 'bar', baz: 42 };
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre>
<p><em>ES2017</em>引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用</p>
<h3 id="objectvalues">Object.values()</h3>
<p>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值</p>
<pre><code class="language-javascript">const obj = { foo: 'bar', baz: 42 };
Object.values(obj)
// [&quot;bar&quot;, 42]
</code></pre>
<p>返回数组的成员顺序与对象属性的遍历介绍的排列顺序一致</p>
<pre><code class="language-javascript">const obj = Object.create({}, {p: {value: 42}});
Object.values(obj) // []
</code></pre>
<p><code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值<br>
<code>Object.values</code>会过滤属性名为 <code>Symbol</code> 值的属性<br>
如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组<br>
如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组</p>
<h3 id="objectentries">Object.entries()</h3>
<p>返回一个数组，成员是参数对象自身的（不含可继承的）所有可遍历属性的键值对数组<br>
除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致</p>
<pre><code class="language-javascript">const obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
</code></pre>
<p>如果原对象的属性名是一个<code>Symbol</code>值，该属性会被忽略，与<code>Object.values()</code>一致<br>
<code>Object.entries</code>只输出属性名非 <code>Symbol</code>值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性<br>
<code>Object.entries</code>的基本用途是遍历对象的属性<br>
<code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构</p>
<h2 id="objectfromentries">Object.fromEntries()</h2>
<p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象</p>
<pre><code class="language-javascript">Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])
// { foo: &quot;bar&quot;, baz: 42 }
</code></pre>
<p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象<br>
该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象</p>
<pre><code class="language-javascript">Object.fromEntries(new URLSearchParams('foo=bar&amp;baz=qux'))
// { foo: &quot;bar&quot;, baz: &quot;qux&quot; }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组的扩展]]></title>
        <id>https://greyseid.github.io/post/shu-zu-de-kuo-zhan/</id>
        <link href="https://greyseid.github.io/post/shu-zu-de-kuo-zhan/">
        </link>
        <updated>2020-11-20T07:24:05.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6">扩展运算符</a>
<ul>
<li><a href="#%E5%90%AB%E4%B9%89">含义</a></li>
<li><a href="#%E6%9B%BF%E4%BB%A3%E6%95%B0%E7%BB%84%E7%9A%84apply%E6%96%B9%E6%B3%95">替代数组的apply方法</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8">扩展运算符的应用</a>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84">合并数组</a></li>
<li><a href="#%E4%B8%8E%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC%E7%BB%93%E5%90%88">与结构赋值结合</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">函数的返回值</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0iterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AF%B9%E8%B1%A1">实现Iterator接口的对象</a></li>
<li><a href="#map%E5%92%8Cset%E7%BB%93%E6%9E%84-generator%E5%87%BD%E6%95%B0">Map和Set结构、Generator函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#arrayfrom">Array.from()</a></li>
<li><a href="#arrayof">Array.of()</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84copywithin">数组实例的copyWithin()</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84find%E5%92%8Cfindindex">数组实例的find()和findIndex()</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E5%8A%9B%E7%9A%84fill">数组实力的fill()</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84entries-keys%E5%92%8Cvalues">数组实例的entries()、keys()和values()</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84includes">数组实例的includes()</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84flastflatmap">数组实例的flast()，flatMap()</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D">数组的空位</a></li>
<li><a href="#arrayprototypesort%E7%9A%84%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7">Array.prototype.sort()的排序稳定性</a></li>
</ul>
</p>
<h1 id="扩展运算符">扩展运算符</h1>
<h2 id="含义">含义</h2>
<p>扩展运算符是三个点...，它如同rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。rest参数相当于接收不定量的参数，形成数组，类似于arguments参数，而扩展运算符...相当于拆解数组。</p>
<pre><code class="language-javascript">console.log(...[1,2,3])//1 2 3
console.log(1,...[2,3,4],5)//1 2 3 4 5
[...document.querySelectorAll('div')]//[&lt;div&gt;,&lt;div&gt;,&lt;div&gt;]
</code></pre>
<h2 id="替代数组的apply方法">替代数组的apply方法</h2>
<p>由于扩展运算符可以展开数组，所以不需要使用apply方法将数组转为函数的参数</p>
<pre><code class="language-javascript">function f(x,y,z){
    //
}
var args=[0,1,2];
f.apply(null,args);//ES5
f(...args);//ES6
</code></pre>
<h2 id="扩展运算符的应用">扩展运算符的应用</h2>
<h3 id="合并数组">合并数组</h3>
<pre><code class="language-javascript">//ES5
[1,2].concat(more)
//ES6
[1,2,...more]
[...arr1,...arr2,...arr3]
</code></pre>
<h3 id="与结构赋值结合">与结构赋值结合</h3>
<p>扩展运算符可以与解构赋值结合起来，并用于生成数组</p>
<pre><code class="language-javascript">//ES5
a=list[0],rest=list.slice(1)
//ES6
[a,...rest]=list
const[first,...rest]=[1,2,3,4,5];
first//1
rest//[2,3,4,5]
const[first,...rest]=[]
first//unddefined
rest//[]
</code></pre>
<p>如果扩展运算符用于数组赋值，则只能将其放在参数的最后一位，否则会报错</p>
<h3 id="函数的返回值">函数的返回值</h3>
<p>JavaScript的函数只能返回一个值，如果需要传回多个值，只能返回数组或对象，拓展运算符提供了一种变通的方法，通过拓展运算符，将传来的数组或对象变为一个参数序列</p>
<h3 id="字符串">字符串</h3>
<p>扩展运算符可以将字符串转换为数组<code>[...'hello']//['h','e','l','l','o']</code><br>
扩展运算符这样写的好处在于能够正确识别32位的Unicode字符</p>
<pre><code class="language-javascript">'x\uD83D\uDE80y'.length//4
[...'x\uD83D\uDE80y'].length//3
</code></pre>
<p>凡是涉及32位Unicode字符的函数都有这个问题，因此最好用扩展运算符改写</p>
<h3 id="实现iterator接口的对象">实现Iterator接口的对象</h3>
<p>任何Iterator接口的对象都可以用扩展运算符转换为真正的数组</p>
<pre><code class="language-javascript">var nodeList=document.querySelectorAll('div');
var array=[...nodeList];
</code></pre>
<p>上面的代码中，querySelectorAll方法返回的是一个nodeList对象，扩展运算符能将其转换为数组，原因在于nodeList对象实现了Iterator<br>
对于没有部署Iterator接口的类似数组的对象，扩展运算符无法将其转为真正的数组</p>
<h3 id="map和set结构-generator函数">Map和Set结构、Generator函数</h3>
<p>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符。<br>
Map结构</p>
<pre><code class="language-javascript">let map=new Map([
    [1,'one'],[2,'two'],[3,'three'],
])
</code></pre>
<p>Generator函数运行后会返回一个遍历器对象</p>
<pre><code class="language-javascript">var go=function*(){
    yield 1;
    yield 2;
    yield 3;
}
[...go()]//[1,2,3]
</code></pre>
<h1 id="arrayfrom">Array.from()</h1>
<p>用于将两类对象转为真正的数组：类似数组的对象和可便利的对象<br>
只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组<br>
如果参数是一个真正的数组，Array.form会返回一个一摸一样的新数组<br>
扩展运算符...也可以将某些数据结构转为数组</p>
<pre><code class="language-javascript">function(){
    var args=[...arguments];
}
</code></pre>
<p>Array.form支持转换类似数组的对象，也就是必须有属性length，有属性length就可以转换为数组，这种情况就不能通过扩展运算符转换<br>
Array.form可以接受第二个参数，类似于数组的map方法，用来同时对每个元素进行处理，处理后放入返回的数组<br>
可以传入第三个参数，用来绑定this<br>
Array.form的另一个应用就是将字符串转换为数组，因为它能正确处理各种Unicode字符</p>
<pre><code class="language-javascript">function(string){
    return Array.from(string).length;
}
</code></pre>
<h1 id="arrayof">Array.of()</h1>
<p>用于将一组值转换为数组<code>Array.of(3,11,8)//[3,11,8]</code><br>
主要目的是弥补数组构造函数Array()的不足，因为参数个数的不同会导致Array()的行为有差异</p>
<pre><code class="language-javascript">Array()//[]
Array(3)//[,,,]
Array(3,11,8)//[3,11,8]
</code></pre>
<p>Array.of基本可以用来代替Array()或new Array()，并且不存在由于参数不同而导致的重载<br>
Array.of总是返回参数值组成的数组。如果没有参数，返回一个空数组</p>
<h1 id="数组实例的copywithin">数组实例的copyWithin()</h1>
<p>数组实例的copyWithin方法会在当前数组内部将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组，使用这个数组会改变当前数组<br>
<code>Array.prototype.copyWithin(target,start=0,end=this.length)</code><br>
接受三个参数</p>
<ul>
<li>target（必选）：从该位置开始替换数据</li>
<li>start（可选）：从该位置开始读取数据，默认为0，如果为负值，表示倒数</li>
<li>end（可选）：到该值前停止读取数据，默认等于数组长度。如果为负值，表示倒数</li>
</ul>
<p>如果参数为非数值，则会转换为数值</p>
<pre><code class="language-javascript">[1,2,3,4,5].copyWithin(0,-2,-1)
//[4,2,3,4,5]
[].copyWithin.call({length:5,3:1},0,3)
//{0:1,3:1,length:5}
</code></pre>
<h1 id="数组实例的find和findindex">数组实例的find()和findIndex()</h1>
<p>数组实例的find方法用于找出第一个符合条件的数组成员。他的参数是一个回调函数，所有数组成员依次执行该回调函数，知道找出第一个返回值为true的成员，然后返回该成员，如果没有符合条件的成员，则返回undefined<br>
数组实例的findIndex方法的用法与find方法类似，返回第一个符合条件的数组的成员的位置，如果所有成员都不符合条件，则返回-1<br>
这两个方法都可以接受第二个参数，用来绑定回调函数的this对象（个人猜测应该是用于箭头函数中的，因为箭头函数没有this指针，所以需要额外传一个进来），都可以发现<strong>NaN</strong>，弥补了数组的IndexOf方法的不足</p>
<h1 id="数组实力的fill">数组实力的fill()</h1>
<p>fill方法使用给定值填充一个数组<br>
fill方法也可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
<pre><code class="language-javascript">['a','b','c'].fill(7,1,2)
//['a',7,'c']
</code></pre>
<h1 id="数组实例的entries-keys和values">数组实例的entries()、keys()和values()</h1>
<p>用于遍历数组，都返回一个遍历器对象，可用for...of循环遍历，区别在于keys()是对键名的遍历，values()是对键值的遍历，entries()是对键值对的遍历</p>
<pre><code class="language-javascript">for(let index of ['a','b'].keys()){
    console.log(index);
}
//0
//1
for(let elem of['a','b'].values()){
    console.log(elem);
}
//'a'
//'b'
for(let[index,elem]of['a','b'].entries()){
    console.log(index,elem);
}
//0&quot;a&quot;
//1&quot;b&quot;
</code></pre>
<p>如果不使用for...of循环，可以手动调用遍历器对象的next方法进行遍历</p>
<pre><code class="language-javascript">let letter=['a','b','c'];
let entries=letter.entries();
console.log(entries.next().value);//[0,'a']
console.log(entries.next().value);//[1,'b']
console.log(entries.next().value);//[2,'c']
</code></pre>
<h1 id="数组实例的includes">数组实例的includes()</h1>
<p>返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似</p>
<pre><code class="language-javascript">[1,2,3].includes(2)//true
[1,2,3].includes(4)//false
[1,2,NaN].includes(NaN)//true
</code></pre>
<p>该方法的第二个参数表示搜索的起始位置，默认为0，如果第二个参数为负数，则表示倒数的位置，如果大于数组的长度，则重置为0<br>
在<code>includes</code>之前，我们通常使用数组的<code>indexOf</code>方法。<code>indexOf</code>有两个缺点，一个是不够语义化，该方法是找到参数出现的第一个位置，比较是否不等于-1，表达起来不够直观，二是由于内部使用了===，所以会对NaN造成误判<code>[NaN].indexOf(NaN)//-1</code><br>
Map和Set数据结构有一个has方法，Map的has方法是用来查找键名的，Set的has方法是用来查找值的</p>
<h1 id="数组实例的flastflatmap">数组实例的flast()，flatMap()</h1>
<p>数组的成员有时还是数组（二维数组等），<code>Array.prototype.flat()</code>用于将嵌套的数组拉平，变成一个一维的数组，该方法返回一个新数组，对原数据没有影响<code>[1,2,[3,4]].flat()//[1,2,3,4]</code><br>
<code>flat()</code>默认只会拉平一层，如果想要拉平多层，可以设置一个参数，表示想拉平的层数，默认为1</p>
<pre><code class="language-javascript">[1,2,[3,[4,5]]].flat()//[1,2,3,[4,5]]
[1,2,[3,[4,5]]].flat(2)//[1,2,3,4,5]
</code></pre>
<p>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数<br>
<code>[1,[2,[3]]].flat(Infinity)//[1,2,3]</code><br>
如果原数组有空位，<code>flat()</code>方法会跳过空位。<code>[1,2,,4,5].flat()//[1,2,4,5]</code><br>
<code>flatMap()</code>方法对原数组的每个成员执行一个函数，相当于map()，然后对返回值组成的数组执行<code>flat()</code>方法，该方法返回一个新数组，不改变原数组</p>
<pre><code class="language-javascript">//相当于[[2,4,],[3,6],[4,8]].flat()
[2,3,4].flatMap((x)=&gt;[x,x*2])
//[2,4,3,6,4,8]
</code></pre>
<p><code>flatMap()</code>只能展开一层数组<br>
<code>flatMap()</code>的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从0开始）、原数组<br>
还可以接受第二个参数，用来绑定遍历函数里面的this</p>
<h1 id="数组的空位">数组的空位</h1>
<p>数组的空位指数组上没有任何值，比如，Array构造函数返回的数组都是空位<code>Array(3)//[,,,]</code><br>
空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的，空位是没有让你和值，<code>in</code>运算符可以说明这一点</p>
<pre><code class="language-javascript">0 in [undefined,undefined,undefined]//true
0 in [,,,]//false
</code></pre>
<p><em>ES5</em>的处理是不一致的，大部分情况会忽略空位</p>
<ul>
<li><code>forEach()</code>,<code>filter()</code>,<code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串</li>
</ul>
<p><em>ES6</em>则是明确将空位转换为<code>undefined</code><br>
数组有空位，for...of并不会忽略，如果改成map方法遍历，空位是会跳过的</p>
<h1 id="arrayprototypesort的排序稳定性">Array.prototype.sort()的排序稳定性</h1>
<p>排序稳定性是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变</p>
<pre><code class="language-javascript">const arr = [
  'peach',
  'straw',
  'apple',
  'spork'
];

const stableSorting = (s1, s2) =&gt; {
  if (s1[0] &lt; s2[0]) return -1;
  return 1;
};

arr.sort(stableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]
</code></pre>
<p>上面代码对数组arr按照首字母进行排序。排序结果中，straw在spork的前面，跟原始顺序一致，所以排序算法stableSorting是稳定排序。</p>
<pre><code class="language-javascript">const unstableSorting = (s1, s2) =&gt; {
  if (s1[0] &lt;= s2[0]) return -1;
  return 1;
};

arr.sort(unstableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;spork&quot;, &quot;straw&quot;]
</code></pre>
<p>上面代码中，排序结果是spork在straw前面，跟原始顺序相反，所以排序算法unstableSorting是不稳定的。<br>
常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行<br>
之前的排序算法是否稳定是交给浏览器自己决定的，现在在<em>ES2019</em>中明确规定<code>Array.prototype.sort()</code>的默认排序算法必须稳定</p>
]]></content>
    </entry>
</feed>