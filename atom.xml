<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://greyseid.github.io/</id>
    <title>正义大厅</title>
    <updated>2020-11-19T14:18:07.464Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://greyseid.github.io/"/>
    <link rel="self" href="https://greyseid.github.io/atom.xml"/>
    <subtitle>欢迎来到GREYSEID的自留地</subtitle>
    <logo>https://greyseid.github.io/images/avatar.png</logo>
    <icon>https://greyseid.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 正义大厅</rights>
    <entry>
        <title type="html"><![CDATA[数值的扩展]]></title>
        <id>https://greyseid.github.io/post/shu-zhi-de-kuo-zhan/</id>
        <link href="https://greyseid.github.io/post/shu-zhi-de-kuo-zhan/">
        </link>
        <updated>2020-11-18T15:29:29.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95">二进制和八进制表示法</a></li>
<li><a href="#numberisfinite-numberisnan">Number.isFinite()、Number.isNaN()</a></li>
<li><a href="#numberparseint-numberparsefloat">Number.parseInt()、Number.parseFloat()</a></li>
<li><a href="#numberisinteger">Number.isInteger()</a></li>
<li><a href="#numberepsilon">Number.EPSILON</a></li>
<li><a href="#%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0%E5%92%8Cnumberissafeinteger">安全整数和Number.isSafeInteger()</a></li>
<li><a href="#math%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%93%E5%B1%95">Math对象的拓展</a>
<ul>
<li><a href="#mathtrunc">Math.trunc()</a></li>
<li><a href="#mathsign">Math.sign()</a></li>
<li><a href="#mathcbrt">Math.cbrt()</a></li>
<li><a href="#mathclz32">MAth.clz32()</a></li>
<li><a href="#mathimul">Math.imul()</a></li>
<li><a href="#mathfround">Math.fround()</a></li>
<li><a href="#mathhypot">Math.hypot()</a></li>
<li><a href="#%E5%AF%B9%E6%95%B0%E6%96%B9%E6%B3%95">对数方法</a>
<ul>
<li><a href="#mathexpm1">Math.expm1()</a></li>
<li><a href="#mathlog1p">Math.log1p()</a></li>
<li><a href="#mathlog10">Math.log10()</a></li>
<li><a href="#mathlog2">Math.log2()</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95">双曲函数方法</a></li>
</ul>
</li>
<li><a href="#mathsignbit%E6%8F%90%E6%A1%88">Math.signbit()——提案</a></li>
<li><a href="#%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6">指数运算符</a></li>
<li><a href="#integer%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8F%90%E6%A1%88">Integer数据类型——提案</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E8%BF%90%E7%AE%97">运算</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="二进制和八进制表示法">二进制和八进制表示法</h1>
<p><em>ES6</em>提供了二进制和八进制的新写法，分别用前缀0b或0B（binary）和0o或0O（octonary）表示。八进制可以使用前缀0表示<code>0O11===011</code>，但是在严格模式中是不允许的，而在<em>ES6</em>中，进一步明确表示要用0O来表示。<br>
如果要将使用0b和0x前缀的字符串数值转为十进制数值，要使用Number方法</p>
<pre><code class="language-javascript">Number('0b111') //7
Number('0o10')  //8
</code></pre>
<h1 id="numberisfinite-numberisnan">Number.isFinite()、Number.isNaN()</h1>
<p><em>ES6</em>在Number对象上提供了Number.isFinite()和Number.isNaN()两个方法。一个用来判断是否有限，一个用来判断是否为NaN(not a number)。</p>
<pre><code class="language-javascript">Number.isFinite(15);        //true
Number.isFinite(0.8);       //true
Number.isFinite(NaN);       //false
Number.isFinite(Infinity);  //false
Number.isFinite(-Infinity); //false
Number.isFinite('foo');     //false
Number.isFinite('15');      //false
Number.isFinite(true);      //false
</code></pre>
<p>新的方法与全局方法<code>isFinite()</code>和<code>isNaN()</code>的不同之处在于，新的方法是不会将传递过来的参数进行转换的，也就是说是不会对非数值进行转换，所以<code>Number.isFinite()</code>对于非数值，会直接返回false，<code>Number.isNaN</code>之对于NaN返回true，其余一律返回false</p>
<h1 id="numberparseint-numberparsefloat">Number.parseInt()、Number.parseFloat()</h1>
<p><em>ES6</em>将<code>parseInt()</code>和<code>parseFloat()</code>移植到了Number对象上，行为完全保持不变</p>
<pre><code class="language-javascript">Number.parseInt('12.34')        //12
Number.parseFloat('123.45#')    //123.45

Number.parseInt===parseInt      //true
Number.parseFloat===parseFloat  //true
</code></pre>
<p>这样做的目的是逐步减少全局性方法，使得语言逐步模块化</p>
<h1 id="numberisinteger">Number.isInteger()</h1>
<p><code>Number.isInteger()</code>用来判断一个值是否为证书。在javascript中，由于整数与浮点数是用同一种方式进行储存，所以3和3.0被视为同一个值</p>
<pre><code class="language-javascript">Number.isInteger(25)    //true
Number.isInteger(25.0)  //true
Number.isInteger(25.1)  //false
Number.isInteger(&quot;15&quot;)  //false
Number.isInteger(true)  //false
</code></pre>
<p><code>Number.isInteger()</code>不会将非数值转换为数值再进行判断</p>
<h1 id="numberepsilon">Number.EPSILON</h1>
<p><em>ES6</em>再Number对象上新增了一个极小的常量——<code>Number.EPSILON //2.220446049250313e-6</code><br>
引入一个这么小的量目的在于为浮点数的计算设置一个误差范围<br>
由于浮点数的计算是不精确的，例如<code>0.1+0.2 //0.30000000000000004</code>，所以如果计算的误差能够小于<code>Number.EPSILON</code>，那么就可以认为得到了正确的结果</p>
<h1 id="安全整数和numberissafeinteger">安全整数和Number.isSafeInteger()</h1>
<p>JavaScript能够准确表示的整数范围在-2<sup>53</sup>到2<sup>53</sup>之间（开区间），这是由于在js中，整数和浮点数是用同样的方法储存的，所以一共有64位储存，但是第1到11位是用来储存指数部分的，整数并不需要指数部分，所以只剩下53位来进行使用</p>
<pre><code class="language-javascript">Math.pow(2,53)  //2^53
Math.pow(2,53)===Math.pow(2,53)+1   //true
</code></pre>
<p>超出2的53次方后，一个数就不精确了<br>
<em>ES6</em>引入了<code>Number.MAX_SAFE_INTEGER //Math.pow(2,53)-1</code>和<code>Number.MIN_SAFE_INTEGER //-(Math.pow(2,53)-1)</code>两个常量来表示整数范围的上下限</p>
<p>使用<code>Number.isSafeInteger()</code>来判断一个整数是否落在这个范围之内时，除了要注意验证计算结果是否在安全整数的范围之内，还要注意参与运算的数是否在范围内</p>
<pre><code class="language-javascript">Number.isSafeInteger(9007199254740993)
//false
Number.isSafeInteger(990)
//true
Number.isSafeInteger(9007199254740993-990)
//true
9007199254740993-990
//返回正确结果：9007199254740002
//正确答案应该是：9007199254740003
</code></pre>
<p>之所以有这个结果是因为参与运算的数<strong>9007199254740993</strong>超出了精度范围，所以计算机内部储存为<strong>9007199254740992</strong>来进行运算，也就是2<sup>53</sup>，而精度范围是不包含这个的，所以不在安全范围内。所以，如果只验证运算结果是否为安全整数，则可能得到错误的结果</p>
<h1 id="math对象的拓展">Math对象的拓展</h1>
<p><em>ES6</em>在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用<br>
大部分方法对于非数值，先转换为数值再进行计算，转换不了则返回NaN或false</p>
<h2 id="mathtrunc">Math.trunc()</h2>
<p>去除一个数的小数部分，返回整数部分<br>
对于非数值，<code>Math.trunc</code>内部使用Number方法转换为数值<code>Math.trunc('123.456')//123</code><br>
对于空值和无法截取整数的值，返回NaN</p>
<pre><code class="language-javascript">Math.trunc(NaN);    //NaN
Math.trunc('foo');  //NaN
Math.trunc();       //NaN
</code></pre>
<h2 id="mathsign">Math.sign()</h2>
<p>判断一个数到底是正数、负数还是零。对于非数值，会先转换为数值<br>
返回值有5种情况</p>
<ul>
<li>参数为正数，返回+1</li>
<li>参数为负数，返回-1</li>
<li>参数为0，返回0</li>
<li>参数为-0，返回-0</li>
<li>其他值，返回NaN</li>
</ul>
<pre><code class="language-javascript">Math.sign(-5)//-1
Math.sign(5)//+1
Math.sign(0)//+0
Math.sign(-0)//-0
Math.sign(NaN)//NaN
Math.sign('9')//+1
Math.sign('foo')//NaN
Math.sign()//NaN
</code></pre>
<h2 id="mathcbrt">Math.cbrt()</h2>
<p>用于计算一个数的立方根<br>
对于非数值，<code>Math.cbrt</code>方法先使用Number方法转换为数值</p>
<pre><code class="language-javascript">Math.cbrt('8')      //2
Math.cbrt('hello')  //NaN
</code></pre>
<h2 id="mathclz32">MAth.clz32()</h2>
<p>JavaScript的整数使用32位二进制形式表示，Math.clz32()返回一个数的32位无符号整数形式有多少个前导0</p>
<pre><code class="language-javascript">Math.clz32(0)//32
Math.clz32(1)//31
MAth.clz32(0b01000000000000000000000000000000)//1
</code></pre>
<p>clz32：“count leading zero bits in 32-bit binary representations of a number”计算32位整数的前导0的缩写<br>
左移计算符&lt;&lt;与Math.clz32直接相关<br>
对于小数，Math.clz32只考虑整数部分<br>
对于空值或其他类型的值，Math.clz32会先将他们转换为数值，然后再计算</p>
<pre><code class="language-javascript">Math.clz32()//32
Math.clz32(NaN)//32
MAth.clz32(Infinity)//32
Math.clz32(null)//32
Math.clz32('foo')//32
Math.clz32([])//32
Math.clz32({})//32
MAth.clz32(true)//32
</code></pre>
<h2 id="mathimul">Math.imul()</h2>
<p>返回两个数以32位带符号位整数形式相乘的结果，返回一个32位带符号整数</p>
<pre><code class="language-javascript">Math.imul(2,4)//4
MAth.imul(-1,8)//-8
Math.imul(-2,-2)//4
</code></pre>
<p>超过32位算溢出<br>
使用这个方法是因为JS有精度限制，超过2<sup>53</sup>的无法精确表示，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值</p>
<h2 id="mathfround">Math.fround()</h2>
<p>返回一个数的单精度浮点数形式<code>Math.fround(1.337)//1.3370000123977661</code><br>
对于整数来说，返回的结果不会不同，区别主要在于那些无法用64个二进制位精确表示的小数，会返回最接近这个小数的单精度浮点数</p>
<h2 id="mathhypot">Math.hypot()</h2>
<p>返回所有参数的平方和的平方根<br>
如果参数不是数值，会将其转换为数值，如果有一个参数无法转换为数值，则返回NaN</p>
<pre><code class="language-javascript">Math.hypot(3,4)//5
Math.hypot(NaN)//NaN
Math.hypot(3,4,'5')//7.0710678118654755
Math.hypot(3,4,'foo')//NaN
</code></pre>
<h2 id="对数方法">对数方法</h2>
<p><em>ES6</em>新增了4个对数相关方法</p>
<h3 id="mathexpm1">Math.expm1()</h3>
<p>Math.expm1(x)返回e<sup>x</sup>-1，即Math.exp(x)-1</p>
<pre><code class="language-javascript">Math.expm1(-1)//0.6321205588285577
Math.expm1(0)//0
Math.expm1(1)//1.718281828459045
</code></pre>
<h3 id="mathlog1p">Math.log1p()</h3>
<p>返回ln(1+x)，即Math.log(1+x)，如果x小于-1，返回NaN</p>
<pre><code class="language-javascript">Math.log1p(1)//0.6931471805599453
Math.log1p(0)//0
Math.log1p(-1)//-Infinity
Math.log1p(-2)//NaN
</code></pre>
<h3 id="mathlog10">Math.log10()</h3>
<p>返回以10为底的x的对数，即log<sub>10</sub>x，如果x小于0，则返回NaN</p>
<pre><code class="language-javascript">Math.log10(2)//0.3010299956639812
Math.log10(1)//0
Math.log(0)//-Infinity
Math.log10(-2)//NaN
Math.log10(100000)//5
</code></pre>
<h3 id="mathlog2">Math.log2()</h3>
<p>返回以2为底的x的对数，即log<sub>2</sub>x，如果x小于0，返回NaN</p>
<pre><code class="language-javascript">Math.log2(3)//1.58462500721156
Math.log2(2)//1
Math.log2(1)//0
Math.log2(0)//-Infinity
Math.log2(-2)//NaN
Math.log2(1024)//10
Math.log2(1&lt;&lt;29)//29
</code></pre>
<h2 id="双曲函数方法">双曲函数方法</h2>
<p><em>ES6</em>新增6个双曲函数方法</p>
<ul>
<li><code>Math.sinh(x)</code> 返回x的双曲正弦</li>
<li><code>Math.cosh(x)</code> 返回x的双曲余弦</li>
<li><code>Math.tanh(x)</code> 返回x的双曲正切</li>
<li><code>Math.asinh(x)</code> 返回x的反双曲正弦</li>
<li><code>Math.acosh(x)</code> 返回x的反双曲余弦</li>
<li><code>Math.atanh(x)</code> 返回x的反双曲正切</li>
</ul>
<h1 id="mathsignbit提案">Math.signbit()——提案</h1>
<p>判断一个数的符号位是否已经设置，这个方法是因为在<code>Math.sign()</code>用来判断正负的时候，-0的结果返回的是-0，但一般来说-0和+0是相等的<code>-0===+0//true</code>，所以不好判断是正是负</p>
<pre><code class="language-javascript">Math.signbit(2)//false
Math.signbit(-2)//true
Math.signbit(0)//false
Math.signbit(-0)//true
</code></pre>
<p>该方法算法如下</p>
<ul>
<li>如果参数是NaN，返回false</li>
<li>如果参数是-0，返回true</li>
<li>如果参数是负值，返回true</li>
<li>其他情况返回false</li>
</ul>
<h1 id="指数运算符">指数运算符</h1>
<p>新增了一个指数运算符(**)</p>
<pre><code class="language-javascript">2**2//4
2**3//8
a**=2//a=a*a
b**=3//b=b*b*b
</code></pre>
<p>在v8引擎中，指数运算符与Math.pow的实现不相同，对于特别大的结果，两者会有细微的差异</p>
<h1 id="integer数据类型提案">Integer数据类型——提案</h1>
<h2 id="简介">简介</h2>
<p>JavaScript所有数字都储存为64位浮点数，使得整数的精确程度只能到53个二进制位，使得JavaScript不适合进行科学和金融方面的精确计算<br>
引入新的数据类型Integer，只用来表示整数，没有位数限制<br>
为了与Number类型区别，Integer类型的数据必须使用后缀n来表示<code>1n+2n//3n</code><br>
JavaScript提供Integer对象，用来生成Integer类型的数值</p>
<pre><code class="language-javascript">Integer(123)//123n
Integer('123')//123n
Integer(false)//0n
Integer(true)//1n
</code></pre>
<p>以下用法会报错</p>
<pre><code class="language-javascript">new Integer()
Integer(undefined)
Integer(null)
Integer('123n')
Integer('abc')
//非数值不会转换为数值
</code></pre>
<h2 id="运算">运算</h2>
<p>Integer类型的+、-、*和**这四个二元运算符与Number类型的行为一致。除法运算/会舍去小数部分，返回一个整数<code>9n/5n //1n</code><br>
几乎所有的Number运算符都可以用在Integer中，但是有两个除外：不带符号的右移运算符&gt;&gt;&gt;和一元的求正运算符+，使用时会报错。&gt;&gt;&gt;要求最高位补0，但是Integer类型没有最高位，这个运算符毫无意义。一元运算符+在asm.js里面总是返回Number类型或报错<br>
Integer类型与Number类型进行混合运算会报错，因为无论返回Integer类型还是Number类型都会丢失信息<code>(2n**53n+1n)+0.5)</code>，返回Integer会丢失0.5这个小数，返回Number会超过53位的精确范围<br>
运算符==会改变数据类型，所以不允许混合使用，===不会改变数据类型，所以可以混合使用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则的拓展]]></title>
        <id>https://greyseid.github.io/post/zheng-ze-de-tuo-zhan/</id>
        <link href="https://greyseid.github.io/post/zheng-ze-de-tuo-zhan/">
        </link>
        <updated>2020-11-16T07:22:32.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#regexp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">RegExp构造函数</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AD%A3%E5%88%99%E6%96%B9%E6%B3%95">字符串的正则方法</a></li>
<li><a href="#u%E4%BF%AE%E9%A5%B0%E7%AC%A6">u修饰符</a>
<ul>
<li><a href="#%E7%82%B9%E5%AD%97%E7%AC%A6">点字符</a></li>
<li><a href="#unicode%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA%E6%B3%95">Unicode字符表示法</a></li>
<li><a href="#%E9%87%8F%E8%AF%8D">量词</a></li>
<li><a href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%BC%8F">预定义模式</a></li>
<li><a href="#i%E4%BF%AE%E9%A5%B0%E7%AC%A6">i修饰符</a></li>
</ul>
</li>
<li><a href="#y%E4%BF%AE%E9%A5%B0%E7%AC%A6">y修饰符</a>
<ul>
<li><a href="#sticky%E5%B1%9E%E6%80%A7">sticky属性</a></li>
</ul>
</li>
<li><a href="#flags%E5%B1%9E%E6%80%A7">flags属性</a></li>
<li><a href="#s%E4%BF%AE%E9%A5%B0%E7%AC%A6dotall%E6%A8%A1%E5%BC%8F%E6%8F%90%E6%A1%88">s修饰符：dotAll模式（提案）</a></li>
<li><a href="#%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80%E6%8F%90%E6%A1%88-v8%E5%BC%95%E6%93%8E49%E7%89%88%E6%9C%AC%E5%B7%B2%E6%94%AF%E6%8C%81">后行断言（提案） ——V8引擎4.9版本已支持</a></li>
<li><a href="#unicode%E5%B1%9E%E6%80%A7%E7%B1%BB%E6%8F%90%E6%A1%88">Unicode属性类（提案）</a></li>
<li><a href="#%E5%85%B7%E5%90%8D%E7%BB%84%E5%8C%B9%E9%85%8D%E6%8F%90%E6%A1%88">具名组匹配（提案）</a>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%9B%BF%E6%8D%A2">结构赋值与替换</a></li>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="regexp构造函数">RegExp构造函数</h1>
<p>在<em>ES5</em>中，使用<strong>RegExp构造函数</strong>时</p>
<pre><code class="language-javascript">var regex=new RegExp('xyz','i');
//或
var regex=new RegExp(/xyz/i);
//等价于
var regex=/xyz/i;
</code></pre>
<p>但是在使用<strong>RegExp构造函数</strong>时，第一个参数为正则表达式，则第二个参数不能添加修饰符</p>
<pre><code class="language-javascript">var regex=new RegExp(/xyz/,'i');
//错误error
</code></pre>
<p>但是在<em>ES6</em>中则发生了变化，它允许使用这种方式混用的方式，并且在使用的时候，如果第一个参数的正则表达式中有修饰符的话，那么第二个参数的修饰符就会覆盖过去，原来的修饰符会被忽略，只会使用新的修饰符</p>
<pre><code class="language-javascript">new RegExp(/xyz/ig,'i').flags;
//&quot;i&quot;
</code></pre>
<h1 id="字符串的正则方法">字符串的正则方法</h1>
<p>字符串对象<code>new String()</code>有四种方法使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code><br>
<em>ES6</em>使四个方法在内部全部调用<strong>RegExp</strong>的实例方法</p>
<h1 id="u修饰符">u修饰符</h1>
<p><em>ES6</em>新增了u修饰符用于正确处理大于\uFFFF的Unicode字符，也就是可以处理4个字节的UTF-16编码</p>
<h2 id="点字符">点字符</h2>
<p>点(.)字符在正则表达式中的含义是除换行符以外的任意单个字符，而大于\uFFFF的Unicode字符，点字符不能识别</p>
<h2 id="unicode字符表示法">Unicode字符表示法</h2>
<p><em>ES6</em>新增了用大括号{}表示Unicode字符的方法，但是在正则表达式中，必须要加上u修饰符才能识别当中的大括号，否则会被解读为量词</p>
<pre><code class="language-javascript">/\u{61}/.test('a')                          //false
/\u{61}/u.test('a')                         //true
/\u{20BB7}/u.test('𠮷')                     //true
</code></pre>
<h2 id="量词">量词</h2>
<p>使用u修饰符后，所有两次都会正确识别码点大于0xFFFF的Unicode字符</p>
<pre><code class="language-javascript">/a{a}/.test('aa')               //true
/a{2}/u.test('aa')              //true
/𠮷{2}/.test('𠮷𠮷')            //false
/𠮷{2}/u.test('𠮷𠮷')           //true
</code></pre>
<h2 id="预定义模式">预定义模式</h2>
<p>u修饰符页影响到预定义模式能否正确识别码点大于0xFFFF的Unicode字符</p>
<h2 id="i修饰符">i修饰符</h2>
<p>有些Unicode字符的编码不同，但是字型相近，比如，\u004B和\u212A都是大写的K</p>
<pre><code class="language-javascript">/[a-z]/i.test('\u212A')             //false
/[a-z]/iu.test('\u212A')            //true
</code></pre>
<p>不加修饰符无法识别非规范的K字符</p>
<h1 id="y修饰符">y修饰符</h1>
<p><em>ES6</em>添加了y修饰符（粘连<em>sticky</em>修饰符）<br>
y修饰符与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就行，而y修饰符会确保匹配必须从剩余的第一个位置开始</p>
<pre><code class="language-javascript">var s=&quot;aaa_aa_a&quot;;
var r1=/a+/g;
var r2=/a+/y;
r1.exec(s)          //[&quot;aaa&quot;]
r2.exec(s)          //[&quot;aaa&quot;]
r1.exec(s)          //[&quot;aa&quot;]
r2.exec(s)          //null
</code></pre>
<p>aaa之后，剩余字符串为&quot;<em>aa_a&quot;，由于第一个位置为&quot;</em>&quot;,所以y修饰符是不会匹配到的，返回null结果</p>
<h2 id="sticky属性">sticky属性</h2>
<p>为了配合y修饰符的使用，添加了sticky属性，表示是否设置了y修饰符</p>
<pre><code class="language-javascript">var r=/hello\d/y;
r.sticky            //true
</code></pre>
<h1 id="flags属性">flags属性</h1>
<p><em>ES6</em>新增了一个flags属性来返回正则表达式的修饰符</p>
<pre><code class="language-javascript">/abc/ig.flags
//'gi'
</code></pre>
<h1 id="s修饰符dotall模式提案">s修饰符：dotAll模式（提案）</h1>
<p>点(.)是一个特殊字符，代表任意的单个字符，但是<strong>行终止符</strong>除外</p>
<ul>
<li>U+000A 换行符(<strong>\n</strong>)</li>
<li>U+000D 回车符(<strong>\r</strong>)</li>
<li>U+2028 行分隔符</li>
<li>U+2029 段分隔符</li>
</ul>
<p><code>/foo.bar/.test('foo\nbar) //false</code>因为(.)不匹配\n，所以正则表达式返回false<br>
可以使用<code>/foo[^]bar/.test('foo\nbar') //true</code><br>
或者引入s修饰符也就是<strong>dotAll模式</strong>，可以匹配任意单个字符</p>
<h1 id="后行断言提案-v8引擎49版本已支持">后行断言（提案） ——V8引擎4.9版本已支持</h1>
<p><em>JavaScript</em>语言的正则表达式只支持先行断言和先行否定断言，不支持后行断言和后行否定断言<br>
<em>先行断言</em>指的是，x只有在y的前面才匹配，例如<code>/x(?=y)/</code>的形式，只匹配百分号之前的数字：<code>/\d+(?=%)/</code>。<em>先行否定断言</em>指的是x只有不在y的后面才匹配，写成<code>/x(?!y)/</code>的形式，只匹配不在百分号前的数字，写成<code>/\d+(?!%)/</code></p>
<pre><code class="language-javascript">/\d+(?=%)/.exec('100% of US presidents have been male')         //[&quot;100&quot;]
/\d+(?!%)/.exec('that’s all 44 of them')                        //[&quot;44&quot;]
</code></pre>
<p><em>后行断言</em>与先行断言相反，x只有在y后面才能匹配，必须写成<code>/(?&lt;=y)x/</code>的形式，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>的形式，<em>后行否定断言</em>也是与先行否定断言相反，只有x不在y后面才匹配，写成<code>/(?&lt;!y)x/</code>的形式，只匹配不在美元符号后面的数字，写成<code>(?&lt;!\$)\d+/</code></p>
<pre><code class="language-javascript">/(?&lt;=\$)\d+/.exec('Benjamin Franklin is on the $100 bill')      //[&quot;100&quot;]
/(?&lt;!\$)\d+/.exec('it‘s is worth about €90')                    //[&quot;90&quot;]
</code></pre>
<p><em>后行断言</em>需要先匹配x，再回到左边匹配y的部分。这种<strong>先右后左</strong>的执行顺序与其他正则操作相反，导致了一些不符合预期的结果</p>
<pre><code class="language-javascript">/(?&lt;=(\d+)(\d+))$/.exec('1053')     //[&quot;&quot;,&quot;1&quot;,&quot;053&quot;]
/^(\d+)(\d+)$/.exec('1053')         //[&quot;1053,&quot;105&quot;,&quot;3&quot;]

/(?&lt;=(o)d\l)r/.exec('hodor')        //null
/(?&lt;=\ld(o))r/.exec('hodor')        //[&quot;r&quot;,&quot;o&quot;]
</code></pre>
<h1 id="unicode属性类提案">Unicode属性类（提案）</h1>
<p>使用<code>\P{...}</code>和<code>\p{...}</code>，允许正则表达式匹配符合Unicode某种属性的所有字符</p>
<pre><code class="language-javascript">const regexGreekSymbol=/\p{Script=Greek}/u;
regexGreeKSymbol.test('Π')      //true
</code></pre>
<h1 id="具名组匹配提案">具名组匹配（提案）</h1>
<h2 id="简介">简介</h2>
<p>正则表达式使用圆括号进行组匹配<code>const RE_DATE=/(\d{4})-(\d{2})-(\d{2})/;</code><br>
组匹配的一个问题是，每一组的匹配含义不容易看出来，只能用数字去引用，要是组的顺序变了，数字引用的时候必须修改序号<br>
具名组匹配的用法就是再模式的头部添加”问号+尖括号+组名“(?<year>)，然后就可以再exec方法返回结果的groups属性上引用该组名。</p>
<h2 id="结构赋值与替换">结构赋值与替换</h2>
<p>使用解构赋值直接从匹配结果上为变量赋值<br>
<code>let {groups:{one,two}}=/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec('foo:bar');</code><br>
字符串替换时，使用$&lt;组名&gt;引用具名组</p>
<pre><code class="language-javascript">let re=/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u;
'2015-01-02'.replace(re,'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;')
//  '02/01/2015'
</code></pre>
<p><em>replace</em>方法的第二个参数是一个字符串，表示格式，而不是正则表达式，第一个才是。<em>replace</em>的第二个参数也可以是函数，接受源字符串、匹配项、开始位置等，返回一个新的字符串</p>
<pre><code class="language-javascript">'2015-01-02'.replace(re,(
    matched,    //整个匹配结果2015-01-02
    capturel1,  //第一个组匹配2015
    capturel2,  //第二个组匹配01
    capturel3,  //第三个组匹配02
    position,   //匹配开始的位置0
    S,          //源字符串2015-01-05
    groups      //具名组构成的一个对象{year,month,day}
)=&gt;{
    let {day,month,year}=args[args.length-1];
    return `${day}/${month}/${year}`;
});
</code></pre>
<p>具名组匹配在原来的基础上新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值</p>
<h2 id="引用">引用</h2>
<p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法，数字引用（\1）依然有效，而且可以混用</p>
<pre><code class="language-javascript">const RE_TWICE=/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$;
RE_TWICE.test('abc!abc!abc')    //true
RE_TWICE.test('abc!abc!ab')     //false
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HELLO！！！]]></title>
        <id>https://greyseid.github.io/post/hello/</id>
        <link href="https://greyseid.github.io/post/hello/">
        </link>
        <updated>2020-11-16T02:57:34.000Z</updated>
        <content type="html"><![CDATA[<p><em><strong>HELLO WORLD!!!</strong></em></p>
<p><em>第一篇博客</em></p>
<p>希望以后能记录更多的内容</p>
]]></content>
    </entry>
</feed>